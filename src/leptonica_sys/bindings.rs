/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LIBLEPT_MAJOR_VERSION: u32 = 1;
pub const LIBLEPT_MINOR_VERSION: u32 = 83;
pub const LIBLEPT_PATCH_VERSION: u32 = 0;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 120300;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const RENAME_SECLUDE: u32 = 1;
pub const RENAME_SWAP: u32 = 2;
pub const RENAME_EXCL: u32 = 4;
pub const RENAME_RESERVED1: u32 = 8;
pub const RENAME_NOFOLLOW_ANY: u32 = 16;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SMOD: u32 = 8192;
pub const __SALC: u32 = 16384;
pub const __SIGN: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 1024;
pub const EOF: i32 = -1;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const P_tmpdir: &[u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: u32 = 1024;
pub const TMP_MAX: u32 = 308915776;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_ctermid: u32 = 1024;
pub const _USE_FORTIFY_LEVEL: u32 = 2;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_CURRENT: u32 = 5;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const __GNUC_VA_LIST: u32 = 1;
pub const HAVE_LIBJPEG: u32 = 0;
pub const HAVE_LIBTIFF: u32 = 0;
pub const HAVE_LIBPNG: u32 = 0;
pub const HAVE_LIBGIF: u32 = 0;
pub const HAVE_LIBUNGIF: u32 = 0;
pub const HAVE_LIBWEBP: u32 = 0;
pub const HAVE_LIBWEBP_ANIM: u32 = 0;
pub const HAVE_LIBJP2K: u32 = 0;
pub const USE_BMPIO: u32 = 0;
pub const USE_PNMIO: u32 = 1;
pub const USE_JP2KHEADER: u32 = 0;
pub const USE_PDFIO: u32 = 0;
pub const USE_PSIO: u32 = 0;
pub const HAVE_FMEMOPEN: u32 = 1;
pub const HAVE_FSTATAT: u32 = 0;
pub const HAVE_DIRFD: u32 = 0;
pub const UNDEF: i32 = -1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const USE_INLINE_ACCESSORS: u32 = 1;
pub const DEWARP_VERSION_NUMBER: u32 = 4;
pub const GPLOT_VERSION_NUMBER: u32 = 1;
pub const NUM_GPLOT_STYLES: u32 = 5;
pub const NUM_GPLOT_OUTPUTS: u32 = 6;
pub const JB_TEMPLATE_EXT: &[u8; 15usize] = b".templates.png\0";
pub const JB_DATA_EXT: &[u8; 6usize] = b".data\0";
pub const SEL_VERSION_NUMBER: u32 = 1;
pub const KERNEL_VERSION_NUMBER: u32 = 2;
pub const PIX_SRC: u32 = 12;
pub const PIX_DST: u32 = 10;
pub const PIX_CLR: u32 = 0;
pub const PIX_SET: u32 = 15;
pub const PIX_PAINT: u32 = 14;
pub const PIX_MASK: u32 = 8;
pub const PIX_XOR: u32 = 6;
pub const RECOG_VERSION_NUMBER: u32 = 2;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: *const ::std::os::raw::c_char,
        arg5: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut ::std::os::raw::c_uchar,
    pub _size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::std::mem::MaybeUninit<__sbuf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut ::std::os::raw::c_uchar,
    pub _r: ::std::os::raw::c_int,
    pub _w: ::std::os::raw::c_int,
    pub _flags: ::std::os::raw::c_short,
    pub _file: ::std::os::raw::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: ::std::os::raw::c_int,
    pub _cookie: *mut ::std::os::raw::c_void,
    pub _close: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *mut ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: fpos_t,
            arg3: ::std::os::raw::c_int,
        ) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: *const ::std::os::raw::c_char,
            arg3: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: ::std::os::raw::c_int,
    pub _ubuf: [::std::os::raw::c_uchar; 3usize],
    pub _nbuf: [::std::os::raw::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: ::std::os::raw::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::std::mem::MaybeUninit<__sFILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._extra) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const ::std::os::raw::c_char, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn freopen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseek(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __nitems: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn perror(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn remove(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ungetc(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fdopen(arg1: ::std::os::raw::c_int, arg2: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(arg1: ::std::os::raw::c_int, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __prefix: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __offset: off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut ::std::os::raw::c_char,
        __size: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        arg1: __builtin_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut ::std::os::raw::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut ::std::os::raw::c_void,
        __size: usize,
        __mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufp: *mut *mut ::std::os::raw::c_char,
        __sizep: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub static sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fmtcheck(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(
        arg1: *mut FILE,
        arg2: *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funopen(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> fpos_t,
        >,
        arg5: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn __sprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __snprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: *const ::std::os::raw::c_char,
        arg5: va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __vsnprintf_chk(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: *const ::std::os::raw::c_char,
        arg6: va_list,
    ) -> ::std::os::raw::c_int;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::std::os::raw::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::std::os::raw::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::std::os::raw::c_int,
    pub sival_ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::std::os::raw::c_int,
    pub sigev_signo: ::std::os::raw::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::std::os::raw::c_int,
    pub si_errno: ::std::os::raw::c_int,
    pub si_code: ::std::os::raw::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::std::os::raw::c_int,
    pub si_addr: *mut ::std::os::raw::c_void,
    pub si_value: sigval,
    pub si_band: ::std::os::raw::c_long,
    pub __pad: [::std::os::raw::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: *mut __siginfo,
            arg3: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::std::os::raw::c_void,
            arg2: ::std::os::raw::c_int,
            arg3: ::std::os::raw::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::std::os::raw::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    pub sv_mask: ::std::os::raw::c_int,
    pub sv_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::std::os::raw::c_char,
    pub ss_onstack: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::std::os::raw::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>,
        ),
    >;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
pub type rusage_info_current = rusage_info_v5;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::std::os::raw::c_int, arg2: id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::std::os::raw::c_int, arg2: *mut rlimit) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::std::os::raw::c_int, arg2: *mut rusage) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpriority(
        arg1: ::std::os::raw::c_int,
        arg2: id_t,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::std::os::raw::c_int, arg2: *const rlimit) -> ::std::os::raw::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::std::os::raw::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::std::os::raw::c_uint,
        w_Coredump: ::std::os::raw::c_uint,
        w_Retcode: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::std::os::raw::c_uint,
        w_Stopsig: ::std::os::raw::c_uint,
        w_Filler: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::std::os::raw::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    ) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wait3(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
pub type wchar_t = __darwin_wchar_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __count: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn div(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn labs(arg1: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::std::os::raw::c_long, arg2: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::std::os::raw::c_longlong, arg2: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(
        arg1: *mut wchar_t,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn strtod(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtold(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::std::os::raw::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::std::os::raw::c_char, arg2: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_int,
        arg4: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        arg1: f64,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const *mut ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::std::os::raw::c_uint,
        arg2: *mut ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::std::os::raw::c_int,
        buffer: *mut ::std::os::raw::c_char,
        buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __overwrite: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::std::os::raw::c_uchar, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetmatch(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn daemon(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getbsize(
        arg1: *mut ::std::os::raw::c_int,
        arg2: *mut ::std::os::raw::c_long,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::std::os::raw::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::std::os::raw::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
                arg3: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::std::os::raw::c_uchar,
        __nel: ::std::os::raw::c_int,
        __table: *const ::std::os::raw::c_uchar,
        __endbyte: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::std::os::raw::c_char,
        __minval: ::std::os::raw::c_longlong,
        __maxval: ::std::os::raw::c_longlong,
        __errstrp: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::std::os::raw::c_char;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type max_align_t = f64;
pub const memory_order_memory_order_relaxed: memory_order = 0;
pub const memory_order_memory_order_consume: memory_order = 1;
pub const memory_order_memory_order_acquire: memory_order = 2;
pub const memory_order_memory_order_release: memory_order = 3;
pub const memory_order_memory_order_acq_rel: memory_order = 4;
pub const memory_order_memory_order_seq_cst: memory_order = 5;
pub type memory_order = ::std::os::raw::c_uint;
extern "C" {
    pub fn atomic_thread_fence(arg1: memory_order);
}
extern "C" {
    pub fn atomic_signal_fence(arg1: memory_order);
}
pub type atomic_bool = u8;
pub type atomic_char = u8;
pub type atomic_schar = u8;
pub type atomic_uchar = u8;
pub type atomic_short = u16;
pub type atomic_ushort = u16;
pub type atomic_int = u32;
pub type atomic_uint = u32;
pub type atomic_long = u64;
pub type atomic_ulong = u64;
pub type atomic_llong = u64;
pub type atomic_ullong = u64;
pub type atomic_char16_t = u16;
pub type atomic_char32_t = u32;
pub type atomic_wchar_t = u32;
pub type atomic_int_least8_t = u8;
pub type atomic_uint_least8_t = u8;
pub type atomic_int_least16_t = u16;
pub type atomic_uint_least16_t = u16;
pub type atomic_int_least32_t = u32;
pub type atomic_uint_least32_t = u32;
pub type atomic_int_least64_t = u64;
pub type atomic_uint_least64_t = u64;
pub type atomic_int_fast8_t = u8;
pub type atomic_uint_fast8_t = u8;
pub type atomic_int_fast16_t = u16;
pub type atomic_uint_fast16_t = u16;
pub type atomic_int_fast32_t = u32;
pub type atomic_uint_fast32_t = u32;
pub type atomic_int_fast64_t = u64;
pub type atomic_uint_fast64_t = u64;
pub type atomic_intptr_t = u64;
pub type atomic_uintptr_t = u64;
pub type atomic_size_t = u64;
pub type atomic_ptrdiff_t = u64;
pub type atomic_intmax_t = u64;
pub type atomic_uintmax_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct atomic_flag {
    pub _Value: atomic_bool,
}
#[test]
fn bindgen_test_layout_atomic_flag() {
    const UNINIT: ::std::mem::MaybeUninit<atomic_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<atomic_flag>(),
        1usize,
        concat!("Size of: ", stringify!(atomic_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<atomic_flag>(),
        1usize,
        concat!("Alignment of ", stringify!(atomic_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(atomic_flag),
            "::",
            stringify!(_Value)
        )
    );
}
extern "C" {
    pub fn atomic_flag_test_and_set(arg1: *mut atomic_flag) -> bool;
}
extern "C" {
    pub fn atomic_flag_test_and_set_explicit(arg1: *mut atomic_flag, arg2: memory_order) -> bool;
}
extern "C" {
    pub fn atomic_flag_clear(arg1: *mut atomic_flag);
}
extern "C" {
    pub fn atomic_flag_clear_explicit(arg1: *mut atomic_flag, arg2: memory_order);
}
pub type l_atomic = atomic_int;
pub type l_intptr_t = isize;
pub type l_uintptr_t = usize;
pub type l_ok = ::std::os::raw::c_int;
pub type l_int8 = ::std::os::raw::c_schar;
pub type l_uint8 = ::std::os::raw::c_uchar;
pub type l_int16 = ::std::os::raw::c_short;
pub type l_uint16 = ::std::os::raw::c_ushort;
pub type l_int32 = ::std::os::raw::c_int;
pub type l_uint32 = ::std::os::raw::c_uint;
pub type l_float32 = f32;
pub type l_float64 = f64;
pub type l_int64 = ::std::os::raw::c_longlong;
pub type l_uint64 = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut LeptDebugOK: l_int32;
}
pub const L_NOT_FOUND: _bindgen_ty_1 = 0;
pub const L_FOUND: _bindgen_ty_1 = 1;
#[doc = " Search State"]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const UNIX_PATH_SEPCHAR: _bindgen_ty_2 = 0;
pub const WIN_PATH_SEPCHAR: _bindgen_ty_2 = 1;
#[doc = " Path Separators"]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type L_TIMER = *mut ::std::os::raw::c_void;
#[doc = " Timing struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WallTimer {
    pub start_sec: l_int32,
    pub start_usec: l_int32,
    pub stop_sec: l_int32,
    pub stop_usec: l_int32,
}
#[test]
fn bindgen_test_layout_L_WallTimer() {
    const UNINIT: ::std::mem::MaybeUninit<L_WallTimer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_WallTimer>(),
        16usize,
        concat!("Size of: ", stringify!(L_WallTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WallTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(L_WallTimer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start_usec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_usec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_sec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop_usec) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_usec)
        )
    );
}
#[doc = " Timing struct"]
pub type L_WALLTIMER = L_WallTimer;
pub const L_SEVERITY_EXTERNAL: _bindgen_ty_3 = 0;
pub const L_SEVERITY_ALL: _bindgen_ty_3 = 1;
pub const L_SEVERITY_DEBUG: _bindgen_ty_3 = 2;
pub const L_SEVERITY_INFO: _bindgen_ty_3 = 3;
pub const L_SEVERITY_WARNING: _bindgen_ty_3 = 4;
pub const L_SEVERITY_ERROR: _bindgen_ty_3 = 5;
pub const L_SEVERITY_NONE: _bindgen_ty_3 = 6;
#[doc = " Control printing of error, warning and info messages */\n/*! Message Control"]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "  The run-time message severity threshold is defined in utils1.c."]
    pub static mut LeptMsgSeverity: l_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numa {
    _unused: [u8; 0],
}
#[doc = " Number array: an array of floats"]
pub type NUMA = Numa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numaa {
    _unused: [u8; 0],
}
#[doc = " Array of number arrays"]
pub type NUMAA = Numaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dna {
    _unused: [u8; 0],
}
#[doc = " Double number array: an array of doubles"]
pub type L_DNA = L_Dna;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dnaa {
    _unused: [u8; 0],
}
#[doc = " Array of double number arrays"]
pub type L_DNAA = L_Dnaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_DnaHash {
    _unused: [u8; 0],
}
#[doc = " Array of double number arrays, used as a simple hash"]
pub type L_DNAHASH = L_DnaHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sarray {
    _unused: [u8; 0],
}
#[doc = " String array: an array of C strings"]
pub type SARRAY = Sarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bytea {
    _unused: [u8; 0],
}
#[doc = " Byte array (analogous to C++ \"string\")"]
pub type L_BYTEA = L_Bytea;
#[doc = "< linear"]
pub const L_LINEAR_INTERP: _bindgen_ty_4 = 1;
#[doc = "< quadratic"]
pub const L_QUADRATIC_INTERP: _bindgen_ty_4 = 2;
#[doc = " Numa Interpolation"]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
#[doc = "< extended with same value"]
pub const L_CONTINUED_BORDER: _bindgen_ty_5 = 1;
#[doc = "< extended with constant normal derivative"]
pub const L_SLOPE_BORDER: _bindgen_ty_5 = 2;
#[doc = "< mirrored"]
pub const L_MIRRORED_BORDER: _bindgen_ty_5 = 3;
#[doc = " Numa Border Adding"]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[doc = "< convert to integer"]
pub const L_INTEGER_VALUE: _bindgen_ty_6 = 1;
#[doc = "< convert to float"]
pub const L_FLOAT_VALUE: _bindgen_ty_6 = 2;
#[doc = " Numa Data Conversion"]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[doc = " Expandable byte buffer for memory read/write operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_ByteBuffer {
    #[doc = "< size of allocated byte array"]
    pub nalloc: l_int32,
    #[doc = "< number of bytes read into to the array"]
    pub n: l_int32,
    #[doc = "< number of bytes written from the array"]
    pub nwritten: l_int32,
    #[doc = "< byte array"]
    pub array: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_ByteBuffer() {
    const UNINIT: ::std::mem::MaybeUninit<L_ByteBuffer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_ByteBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nwritten) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nwritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(array)
        )
    );
}
#[doc = " Expandable byte buffer for memory read/write operations"]
pub type L_BBUFFER = L_ByteBuffer;
#[doc = " General hash map"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashmap {
    #[doc = "< number of stored items"]
    pub nitems: l_int32,
    #[doc = "< number of items to be stored        */\n/*!< before resizing the hashmap"]
    pub ntogo: l_int32,
    #[doc = "< max average occupancy allowed"]
    pub maxocc: l_int32,
    #[doc = "< array of hash item ptrs"]
    pub hashtab: *mut *mut L_Hashitem,
    #[doc = "< size of array of hash item ptrs"]
    pub tabsize: l_int32,
}
#[test]
fn bindgen_test_layout_L_Hashmap() {
    const UNINIT: ::std::mem::MaybeUninit<L_Hashmap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Hashmap>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashmap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashmap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashmap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nitems) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(nitems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ntogo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(ntogo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxocc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(maxocc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashtab) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(hashtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tabsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(tabsize)
        )
    );
}
#[doc = " General hash map"]
pub type L_HASHMAP = L_Hashmap;
#[doc = " Hash item, containing storage for the key, value and count.  The key\nis a l_uint64, which is hashed by the mod function to find the index\ninto the hashtab."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashitem {
    #[doc = "< key is hashed into index into hashtab"]
    pub key: l_uint64,
    #[doc = "< number stored associated with the key"]
    pub val: l_uint64,
    #[doc = "< number of elements seen with this key"]
    pub count: l_int32,
    #[doc = "< ptr to the next in the list"]
    pub next: *mut L_Hashitem,
}
#[test]
fn bindgen_test_layout_L_Hashitem() {
    const UNINIT: ::std::mem::MaybeUninit<L_Hashitem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Hashitem>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashitem))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashitem>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashitem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Hash item, containing storage for the key, value and count.  The key\nis a l_uint64, which is hashed by the mod function to find the index\ninto the hashtab."]
pub type L_HASHITEM = L_Hashitem;
#[doc = "< invalid operation"]
pub const L_UNDEFINED: _bindgen_ty_7 = 0;
#[doc = "< check if this key/val has been stored"]
pub const L_HMAP_CHECK: _bindgen_ty_7 = 1;
#[doc = "< create and store a hashitem if not found"]
pub const L_HMAP_CREATE: _bindgen_ty_7 = 2;
#[doc = " Hashmap Lookup"]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = " Heap of arbitrary void* data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Heap {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of elements stored in the heap"]
    pub n: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< L_SORT_INCREASING or L_SORT_DECREASING"]
    pub direction: l_int32,
}
#[test]
fn bindgen_test_layout_L_Heap() {
    const UNINIT: ::std::mem::MaybeUninit<L_Heap> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Heap>(),
        24usize,
        concat!("Size of: ", stringify!(L_Heap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Heap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Heap))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Heap), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(direction)
        )
    );
}
#[doc = " Heap of arbitrary void* data"]
pub type L_HEAP = L_Heap;
#[doc = " \\file list.h\n\n <pre>\n       Cell for double-linked lists\n\n       This allows composition of a list of cells with\n           prev, next and data pointers.  Generic data\n           structures hang on the list cell data pointers.\n\n       The list is not circular because that would add much\n           complexity in traversing the list under general\n           conditions where list cells can be added and removed.\n           The only disadvantage of not having the head point to\n           the last cell is that the list must be traversed to\n           find its tail.  However, this traversal is fast, and\n           the listRemoveFromTail() function updates the tail\n           so there is no searching overhead with repeated use.\n\n       The list macros are used to run through a list, and their\n       use is encouraged.  They are invoked, e.g., as\n\n             DLLIST  *head, *elem;\n             ...\n             L_BEGIN_LIST_FORWARD(head, elem)\n                 <do something with elem and/or elem->data >\n             L_END_LIST\n </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoubleLinkedList {
    pub prev: *mut DoubleLinkedList,
    pub next: *mut DoubleLinkedList,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DoubleLinkedList() {
    const UNINIT: ::std::mem::MaybeUninit<DoubleLinkedList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DoubleLinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        ::std::mem::align_of::<DoubleLinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\file list.h\n\n <pre>\n       Cell for double-linked lists\n\n       This allows composition of a list of cells with\n           prev, next and data pointers.  Generic data\n           structures hang on the list cell data pointers.\n\n       The list is not circular because that would add much\n           complexity in traversing the list under general\n           conditions where list cells can be added and removed.\n           The only disadvantage of not having the head point to\n           the last cell is that the list must be traversed to\n           find its tail.  However, this traversal is fast, and\n           the listRemoveFromTail() function updates the tail\n           so there is no searching overhead with repeated use.\n\n       The list macros are used to run through a list, and their\n       use is encouraged.  They are invoked, e.g., as\n\n             DLLIST  *head, *elem;\n             ...\n             L_BEGIN_LIST_FORWARD(head, elem)\n                 <do something with elem and/or elem->data >\n             L_END_LIST\n </pre>"]
pub type DLLIST = DoubleLinkedList;
extern "C" {
    #[doc = " \\file ptra.h\n\n <pre>\n  Contains the following structs:\n      struct L_Ptra\n      struct L_Ptraa\n\n  Contains definitions for:\n      L_Ptra compaction flags for removal\n      L_Ptra shifting flags for insert\n      L_Ptraa accessor flags\n </pre>"]
    pub static MaxInitPtraSize: l_uint32;
}
#[doc = " Generic pointer array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptra {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< greatest valid index"]
    pub imax: l_int32,
    #[doc = "< actual number of stored elements"]
    pub nactual: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_L_Ptra() {
    const UNINIT: ::std::mem::MaybeUninit<L_Ptra> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Ptra>(),
        24usize,
        concat!("Size of: ", stringify!(L_Ptra))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptra>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptra))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).imax) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(imax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nactual) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nactual)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(array)
        )
    );
}
#[doc = " Generic pointer array"]
pub type L_PTRA = L_Ptra;
#[doc = " Array of generic pointer arrays"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptraa {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< array of ptra"]
    pub ptra: *mut *mut L_Ptra,
}
#[test]
fn bindgen_test_layout_L_Ptraa() {
    const UNINIT: ::std::mem::MaybeUninit<L_Ptraa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Ptraa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Ptraa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptraa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptraa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptra) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(ptra)
        )
    );
}
#[doc = " Array of generic pointer arrays"]
pub type L_PTRAA = L_Ptraa;
#[doc = "< null the pointer only"]
pub const L_NO_COMPACTION: _bindgen_ty_8 = 1;
#[doc = "< compact the array"]
pub const L_COMPACTION: _bindgen_ty_8 = 2;
#[doc = " Ptra Removal"]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = "< choose based on number of holes"]
pub const L_AUTO_DOWNSHIFT: _bindgen_ty_9 = 0;
#[doc = "< downshifts min # of ptrs below insert"]
pub const L_MIN_DOWNSHIFT: _bindgen_ty_9 = 1;
#[doc = "< downshifts all ptrs below insert"]
pub const L_FULL_DOWNSHIFT: _bindgen_ty_9 = 2;
#[doc = " Ptra Insertion"]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[doc = "< ptr to L_Ptra; caller can inspect only"]
pub const L_HANDLE_ONLY: _bindgen_ty_10 = 0;
#[doc = "< caller owns; destroy or save in L_Ptraa"]
pub const L_REMOVE: _bindgen_ty_10 = 1;
#[doc = " Ptraa Accessor"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[doc = " Expandable pointer queue for arbitrary void* data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Queue {
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< location of head (in ptrs) from the    */\n/*!< beginning of the array"]
    pub nhead: l_int32,
    #[doc = "< number of elements stored in the queue"]
    pub nelem: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< auxiliary stack"]
    pub stack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Queue() {
    const UNINIT: ::std::mem::MaybeUninit<L_Queue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Queue>(),
        32usize,
        concat!("Size of: ", stringify!(L_Queue))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Queue>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Queue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nhead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nhead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nelem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nelem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(stack)
        )
    );
}
#[doc = " Expandable pointer queue for arbitrary void* data"]
pub type L_QUEUE = L_Queue;
pub const L_INT_TYPE: _bindgen_ty_11 = 1;
pub const L_UINT_TYPE: _bindgen_ty_11 = 2;
pub const L_FLOAT_TYPE: _bindgen_ty_11 = 3;
#[doc = " The three valid key types for red-black trees, maps and sets. */\n/*! RBTree Key Type"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[doc = " Storage for keys and values for red-black trees, maps and sets.\n <pre>\n Note:\n   (1) Keys and values of the valid key types are all 64-bit\n   (2) (void *) can be used for values but not for keys.\n </pre>"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rb_Type {
    pub itype: l_int64,
    pub utype: l_uint64,
    pub ftype: l_float64,
    pub ptype: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Rb_Type() {
    const UNINIT: ::std::mem::MaybeUninit<Rb_Type> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Rb_Type>(),
        8usize,
        concat!("Size of: ", stringify!(Rb_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Rb_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(Rb_Type))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).utype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(utype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ftype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ptype)
        )
    );
}
#[doc = " Storage for keys and values for red-black trees, maps and sets.\n <pre>\n Note:\n   (1) Keys and values of the valid key types are all 64-bit\n   (2) (void *) can be used for values but not for keys.\n </pre>"]
pub type RB_TYPE = Rb_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rbtree {
    pub root: *mut L_Rbtree_Node,
    pub keytype: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree() {
    const UNINIT: ::std::mem::MaybeUninit<L_Rbtree> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree>(),
        16usize,
        concat!("Size of: ", stringify!(L_Rbtree))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).root) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keytype) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(keytype)
        )
    );
}
pub type L_RBTREE = L_Rbtree;
pub type L_AMAP = L_Rbtree;
pub type L_ASET = L_Rbtree;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct L_Rbtree_Node {
    pub key: Rb_Type,
    pub value: Rb_Type,
    pub left: *mut L_Rbtree_Node,
    pub right: *mut L_Rbtree_Node,
    pub parent: *mut L_Rbtree_Node,
    pub color: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree_Node() {
    const UNINIT: ::std::mem::MaybeUninit<L_Rbtree_Node> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree_Node>(),
        48usize,
        concat!("Size of: ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(color)
        )
    );
}
pub type L_RBTREE_NODE = L_Rbtree_Node;
pub type L_AMAP_NODE = L_Rbtree_Node;
pub type L_ASET_NODE = L_Rbtree_Node;
#[doc = " Expandable pointer stack for arbitrary void* data.\n Note that array[n] is the first null ptr in the array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Stack {
    #[doc = "< size of ptr array"]
    pub nalloc: l_int32,
    #[doc = "< number of stored elements"]
    pub n: l_int32,
    #[doc = "< ptr array"]
    pub array: *mut *mut ::std::os::raw::c_void,
    #[doc = "< auxiliary stack"]
    pub auxstack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Stack() {
    const UNINIT: ::std::mem::MaybeUninit<L_Stack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Stack>(),
        24usize,
        concat!("Size of: ", stringify!(L_Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Stack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auxstack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(auxstack)
        )
    );
}
#[doc = " Expandable pointer stack for arbitrary void* data.\n Note that array[n] is the first null ptr in the array"]
pub type L_STACK = L_Stack;
#[doc = "< tab or space at beginning of line"]
pub const SPLIT_ON_LEADING_WHITE: _bindgen_ty_12 = 1;
#[doc = "< newline with optional white space"]
pub const SPLIT_ON_BLANK_LINE: _bindgen_ty_12 = 2;
#[doc = "< leading white space or newline"]
pub const SPLIT_ON_BOTH: _bindgen_ty_12 = 3;
#[doc = " Constants for deciding when text block is divided into paragraphs */\n/*! Split Text"]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[doc = " Data structure to hold bitmap fonts and related data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bmf {
    #[doc = "< pixa of bitmaps for 93 characters"]
    pub pixa: *mut Pixa,
    #[doc = "< font size (in points at 300 ppi)"]
    pub size: l_int32,
    #[doc = "< directory containing font bitmaps"]
    pub directory: *mut ::std::os::raw::c_char,
    #[doc = "< baseline offset for ascii 33 - 57"]
    pub baseline1: l_int32,
    #[doc = "< baseline offset for ascii 58 - 91"]
    pub baseline2: l_int32,
    #[doc = "< baseline offset for ascii 93 - 126"]
    pub baseline3: l_int32,
    #[doc = "< max height of line of chars"]
    pub lineheight: l_int32,
    #[doc = "< pixel dist between char bitmaps"]
    pub kernwidth: l_int32,
    #[doc = "< pixel dist between word bitmaps"]
    pub spacewidth: l_int32,
    #[doc = "< extra vertical space between text lines"]
    pub vertlinesep: l_int32,
    #[doc = "< table mapping ascii --> font index"]
    pub fonttab: *mut l_int32,
    #[doc = "< table mapping ascii --> baseline offset"]
    pub baselinetab: *mut l_int32,
    #[doc = "< table mapping ascii --> char width"]
    pub widthtab: *mut l_int32,
}
#[test]
fn bindgen_test_layout_L_Bmf() {
    const UNINIT: ::std::mem::MaybeUninit<L_Bmf> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Bmf>(),
        80usize,
        concat!("Size of: ", stringify!(L_Bmf))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bmf>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bmf))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).directory) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(directory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseline1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseline2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseline3) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lineheight) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(lineheight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kernwidth) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(kernwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spacewidth) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(spacewidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vertlinesep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(vertlinesep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fonttab) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(fonttab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baselinetab) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baselinetab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).widthtab) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(widthtab)
        )
    );
}
#[doc = " Data structure to hold bitmap fonts and related data"]
pub type L_BMF = L_Bmf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBord {
    _unused: [u8; 0],
}
#[doc = " A single CCBord for a connected component"]
pub type CCBORD = CCBord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBorda {
    _unused: [u8; 0],
}
#[doc = " Array of CCBord"]
pub type CCBORDA = CCBorda;
pub const CCB_LOCAL_COORDS: _bindgen_ty_13 = 1;
pub const CCB_GLOBAL_COORDS: _bindgen_ty_13 = 2;
#[doc = " Use in ccbaStepChainsToPixCoords() */\n/*! CCB Coords"]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const CCB_SAVE_ALL_PTS: _bindgen_ty_14 = 1;
pub const CCB_SAVE_TURNING_PTS: _bindgen_ty_14 = 2;
#[doc = " Use in ccbaGenerateSPGlobalLocs() */\n/*! CCB Points"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[doc = " Colorfill data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Colorfill {
    #[doc = "< clone of source pix"]
    pub pixs: *mut Pix,
    #[doc = "< source pix, after optional transform"]
    pub pixst: *mut Pix,
    #[doc = "< number of tiles in each tile row"]
    pub nx: l_int32,
    #[doc = "< number of tiles in each tile column"]
    pub ny: l_int32,
    #[doc = "< width of each tile"]
    pub tw: l_int32,
    #[doc = "< height of each tile"]
    pub th: l_int32,
    #[doc = "< min number of pixels in a color region"]
    pub minarea: l_int32,
    #[doc = "< tile locations"]
    pub boxas: *mut Boxa,
    #[doc = "< tiles from source pix"]
    pub pixas: *mut Pixa,
    #[doc = "< mask tiles with components covering    */\n/*!< regions with similar color"]
    pub pixam: *mut Pixa,
    #[doc = "< sizes of color regions (in pixels)"]
    pub naa: *mut Numaa,
    #[doc = "< average color in each region"]
    pub dnaa: *mut L_Dnaa,
    #[doc = "< debug reconstruction from segmentation"]
    pub pixadb: *mut Pixa,
}
#[test]
fn bindgen_test_layout_L_Colorfill() {
    const UNINIT: ::std::mem::MaybeUninit<L_Colorfill> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Colorfill>(),
        88usize,
        concat!("Size of: ", stringify!(L_Colorfill))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Colorfill>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Colorfill))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixst) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ny) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tw) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(tw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).th) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(th)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minarea) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(minarea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boxas) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(boxas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixas) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixam) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naa) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(naa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dnaa) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(dnaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixadb) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixadb)
        )
    );
}
#[doc = " Colorfill data"]
pub type L_COLORFILL = L_Colorfill;
#[doc = " Data structure to hold a number of Dewarp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarpa {
    #[doc = "< size of dewarp ptr array"]
    pub nalloc: l_int32,
    #[doc = "< maximum page number in array"]
    pub maxpage: l_int32,
    #[doc = "< array of ptrs to page dewarp"]
    pub dewarp: *mut *mut L_Dewarp,
    #[doc = "< array of ptrs to cached dewarps"]
    pub dewarpcache: *mut *mut L_Dewarp,
    #[doc = "< list of page numbers for pages    */\n/*!< with page models"]
    pub namodels: *mut Numa,
    #[doc = "< list of page numbers with either  */\n/*!< page models or ref page models"]
    pub napages: *mut Numa,
    #[doc = "< reduction factor of input: 1 or 2"]
    pub redfactor: l_int32,
    #[doc = "< disparity arrays sampling factor"]
    pub sampling: l_int32,
    #[doc = "< min number of long lines required"]
    pub minlines: l_int32,
    #[doc = "< max distance for getting ref page"]
    pub maxdist: l_int32,
    #[doc = "< maximum abs line curvature,       */\n/*!< in micro-units"]
    pub max_linecurv: l_int32,
    #[doc = "< minimum abs diff line         */\n/*!< curvature in micro-units"]
    pub min_diff_linecurv: l_int32,
    #[doc = "< maximum abs diff line         */\n/*!< curvature in micro-units"]
    pub max_diff_linecurv: l_int32,
    #[doc = "< maximum abs left or right edge    */\n/*!< slope, in milli-units"]
    pub max_edgeslope: l_int32,
    #[doc = "< maximum abs left or right edge    */\n/*!< curvature, in micro-units"]
    pub max_edgecurv: l_int32,
    #[doc = "< maximum abs diff left-right   */\n/*!< edge curvature, in micro-units"]
    pub max_diff_edgecurv: l_int32,
    #[doc = "< use both disparity arrays if      */\n/*!< available; only vertical otherwise"]
    pub useboth: l_int32,
    #[doc = "< if there are multiple columns,    */\n/*!< only use the vertical disparity   */\n/*!< array"]
    pub check_columns: l_int32,
    #[doc = "< invalid models have been removed  */\n/*!< and refs built against valid set"]
    pub modelsready: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarpa() {
    const UNINIT: ::std::mem::MaybeUninit<L_Dewarpa> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Dewarpa>(),
        96usize,
        concat!("Size of: ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarpa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxpage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxpage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dewarp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dewarpcache) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarpcache)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namodels) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(namodels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).napages) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(napages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).redfactor) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minlines) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxdist) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_linecurv) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_linecurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_diff_linecurv) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(min_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_diff_linecurv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_edgeslope) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgeslope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_edgecurv) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgecurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_diff_edgecurv) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_edgecurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useboth) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(useboth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).check_columns) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(check_columns)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).modelsready) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(modelsready)
        )
    );
}
#[doc = " Data structure to hold a number of Dewarp"]
pub type L_DEWARPA = L_Dewarpa;
#[doc = " Data structure for a single dewarp"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarp {
    #[doc = "< ptr to parent (not owned)"]
    pub dewa: *mut L_Dewarpa,
    #[doc = "< source pix, 1 bpp"]
    pub pixs: *mut Pix,
    #[doc = "< sampled vert disparity array"]
    pub sampvdispar: *mut FPix,
    #[doc = "< sampled horiz disparity array"]
    pub samphdispar: *mut FPix,
    #[doc = "< sampled slope h-disparity array"]
    pub sampydispar: *mut FPix,
    #[doc = "< full vert disparity array"]
    pub fullvdispar: *mut FPix,
    #[doc = "< full horiz disparity array"]
    pub fullhdispar: *mut FPix,
    #[doc = "< full slope h-disparity array"]
    pub fullydispar: *mut FPix,
    #[doc = "< sorted y val of midpoint each line"]
    pub namidys: *mut Numa,
    #[doc = "< sorted curvature of each line"]
    pub nacurves: *mut Numa,
    #[doc = "< width of source image"]
    pub w: l_int32,
    #[doc = "< height of source image"]
    pub h: l_int32,
    #[doc = "< page number; important for reuse"]
    pub pageno: l_int32,
    #[doc = "< sampling factor of disparity arrays"]
    pub sampling: l_int32,
    #[doc = "< reduction factor of pixs: 1 or 2"]
    pub redfactor: l_int32,
    #[doc = "< min number of long lines required"]
    pub minlines: l_int32,
    #[doc = "< number of long lines found"]
    pub nlines: l_int32,
    #[doc = "< min line curvature in micro-units"]
    pub mincurv: l_int32,
    #[doc = "< max line curvature in micro-units"]
    pub maxcurv: l_int32,
    #[doc = "< left edge slope in milli-units"]
    pub leftslope: l_int32,
    #[doc = "< right edge slope in milli-units"]
    pub rightslope: l_int32,
    #[doc = "< left edge curvature in micro-units"]
    pub leftcurv: l_int32,
    #[doc = "< right edge curvature in micro-units"]
    pub rightcurv: l_int32,
    #[doc = "< number of sampling pts in x-dir"]
    pub nx: l_int32,
    #[doc = "< number of sampling pts in y-dir"]
    pub ny: l_int32,
    #[doc = "< 0 if normal; 1 if has a refpage"]
    pub hasref: l_int32,
    #[doc = "< page with disparity model to use"]
    pub refpage: l_int32,
    #[doc = "< sets to 1 if vert disparity builds"]
    pub vsuccess: l_int32,
    #[doc = "< sets to 1 if horiz disparity builds"]
    pub hsuccess: l_int32,
    #[doc = "< sets to 1 if slope disparity builds"]
    pub ysuccess: l_int32,
    #[doc = "< sets to 1 if valid vert disparity"]
    pub vvalid: l_int32,
    #[doc = "< sets to 1 if valid horiz disparity"]
    pub hvalid: l_int32,
    #[doc = "< if 1, skip horiz disparity         */\n/*!< correction"]
    pub skip_horiz: l_int32,
    #[doc = "< set to 1 if debug output requested"]
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarp() {
    const UNINIT: ::std::mem::MaybeUninit<L_Dewarp> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Dewarp>(),
        176usize,
        concat!("Size of: ", stringify!(L_Dewarp))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarp>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarp))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dewa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(dewa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampvdispar) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampvdispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).samphdispar) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(samphdispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampydispar) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampydispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullvdispar) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullvdispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullhdispar) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullhdispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullydispar) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullydispar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namidys) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(namidys)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nacurves) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nacurves)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pageno) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sampling) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).redfactor) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minlines) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nlines) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nlines)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mincurv) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(mincurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcurv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(maxcurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftslope) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftslope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rightslope) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightslope)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).leftcurv) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftcurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rightcurv) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightcurv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nx) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ny) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasref) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hasref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refpage) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(refpage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vsuccess) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vsuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hsuccess) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hsuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysuccess) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ysuccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vvalid) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vvalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hvalid) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hvalid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_horiz) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(skip_horiz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(debug)
        )
    );
}
#[doc = " Data structure for a single dewarp"]
pub type L_DEWARP = L_Dewarp;
pub const GPLOT_STYLE_GPLOT_LINES: GPLOT_STYLE = 0;
pub const GPLOT_STYLE_GPLOT_POINTS: GPLOT_STYLE = 1;
pub const GPLOT_STYLE_GPLOT_IMPULSES: GPLOT_STYLE = 2;
pub const GPLOT_STYLE_GPLOT_LINESPOINTS: GPLOT_STYLE = 3;
pub const GPLOT_STYLE_GPLOT_DOTS: GPLOT_STYLE = 4;
pub type GPLOT_STYLE = ::std::os::raw::c_uint;
pub const GPLOT_OUTPUT_GPLOT_NONE: GPLOT_OUTPUT = 0;
pub const GPLOT_OUTPUT_GPLOT_PNG: GPLOT_OUTPUT = 1;
pub const GPLOT_OUTPUT_GPLOT_PS: GPLOT_OUTPUT = 2;
pub const GPLOT_OUTPUT_GPLOT_EPS: GPLOT_OUTPUT = 3;
pub const GPLOT_OUTPUT_GPLOT_LATEX: GPLOT_OUTPUT = 4;
pub const GPLOT_OUTPUT_GPLOT_PNM: GPLOT_OUTPUT = 5;
pub type GPLOT_OUTPUT = ::std::os::raw::c_uint;
#[doc = "< default"]
pub const GPLOT_SCALING_GPLOT_LINEAR_SCALE: GPLOT_SCALING = 0;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X: GPLOT_SCALING = 1;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_Y: GPLOT_SCALING = 2;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X_Y: GPLOT_SCALING = 3;
pub type GPLOT_SCALING = ::std::os::raw::c_uint;
extern "C" {
    #[doc = "< used in gnuplot cmd file"]
    pub static mut gplotstylenames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[doc = "< used in simple file input"]
    pub static mut gplotfileoutputs: [*const ::std::os::raw::c_char; 0usize];
}
#[doc = " Data structure for generating gnuplot files"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPlot {
    #[doc = "< for cmd, data, output"]
    pub rootname: *mut ::std::os::raw::c_char,
    #[doc = "< command file name"]
    pub cmdname: *mut ::std::os::raw::c_char,
    #[doc = "< command file contents"]
    pub cmddata: *mut Sarray,
    #[doc = "< data file names"]
    pub datanames: *mut Sarray,
    #[doc = "< plot data (1 string/file)"]
    pub plotdata: *mut Sarray,
    #[doc = "< label for each individual plot"]
    pub plotlabels: *mut Sarray,
    #[doc = "< plot style for individual plots"]
    pub plotstyles: *mut Numa,
    #[doc = "< current number of plots"]
    pub nplots: l_int32,
    #[doc = "< output file name"]
    pub outname: *mut ::std::os::raw::c_char,
    #[doc = "< GPLOT_OUTPUT values"]
    pub outformat: l_int32,
    #[doc = "< GPLOT_SCALING values"]
    pub scaling: l_int32,
    #[doc = "< optional"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< optional x axis label"]
    pub xlabel: *mut ::std::os::raw::c_char,
    #[doc = "< optional y axis label"]
    pub ylabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GPlot() {
    const UNINIT: ::std::mem::MaybeUninit<GPlot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GPlot>(),
        104usize,
        concat!("Size of: ", stringify!(GPlot))
    );
    assert_eq!(
        ::std::mem::align_of::<GPlot>(),
        8usize,
        concat!("Alignment of ", stringify!(GPlot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rootname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(rootname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmdname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmdname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmddata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmddata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datanames) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(datanames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plotdata) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotdata)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plotlabels) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotlabels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).plotstyles) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotstyles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nplots) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(nplots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outname) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outformat) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outformat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xlabel) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(xlabel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ylabel) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(ylabel)
        )
    );
}
#[doc = " Data structure for generating gnuplot files"]
pub type GPLOT = GPlot;
pub const IFF_UNKNOWN: _bindgen_ty_15 = 0;
pub const IFF_BMP: _bindgen_ty_15 = 1;
pub const IFF_JFIF_JPEG: _bindgen_ty_15 = 2;
pub const IFF_PNG: _bindgen_ty_15 = 3;
pub const IFF_TIFF: _bindgen_ty_15 = 4;
pub const IFF_TIFF_PACKBITS: _bindgen_ty_15 = 5;
pub const IFF_TIFF_RLE: _bindgen_ty_15 = 6;
pub const IFF_TIFF_G3: _bindgen_ty_15 = 7;
pub const IFF_TIFF_G4: _bindgen_ty_15 = 8;
pub const IFF_TIFF_LZW: _bindgen_ty_15 = 9;
pub const IFF_TIFF_ZIP: _bindgen_ty_15 = 10;
pub const IFF_PNM: _bindgen_ty_15 = 11;
pub const IFF_PS: _bindgen_ty_15 = 12;
pub const IFF_GIF: _bindgen_ty_15 = 13;
pub const IFF_JP2: _bindgen_ty_15 = 14;
pub const IFF_WEBP: _bindgen_ty_15 = 15;
pub const IFF_LPDF: _bindgen_ty_15 = 16;
pub const IFF_TIFF_JPEG: _bindgen_ty_15 = 17;
pub const IFF_DEFAULT: _bindgen_ty_15 = 18;
pub const IFF_SPIX: _bindgen_ty_15 = 19;
#[doc = " Image Formats"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
#[doc = "< BM - for bitmaps"]
pub const BMP_ID: _bindgen_ty_16 = 19778;
#[doc = "< MM - for 'motorola'"]
pub const TIFF_BIGEND_ID: _bindgen_ty_16 = 19789;
#[doc = "< II - for 'intel'"]
pub const TIFF_LITTLEEND_ID: _bindgen_ty_16 = 18761;
#[doc = " Header Ids"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
#[doc = "< only want luminance data; no chroma"]
pub const L_JPEG_READ_LUMINANCE: _bindgen_ty_17 = 1;
#[doc = "< return possibly damaged pix"]
pub const L_JPEG_CONTINUE_WITH_BAD_DATA: _bindgen_ty_17 = 2;
#[doc = " Jpeg Hints"]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[doc = "< codestream"]
pub const L_J2K_CODEC: _bindgen_ty_18 = 1;
#[doc = "< file format with 'ihdr'"]
pub const L_JP2_CODEC: _bindgen_ty_18 = 2;
#[doc = " Jp2k Codecs"]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[doc = "< use default encoding based on image"]
pub const L_DEFAULT_ENCODE: _bindgen_ty_19 = 0;
#[doc = "< use dct encoding: 8 and 32 bpp, no cmap"]
pub const L_JPEG_ENCODE: _bindgen_ty_19 = 1;
#[doc = "< use ccitt g4 fax encoding: 1 bpp"]
pub const L_G4_ENCODE: _bindgen_ty_19 = 2;
#[doc = "< use flate encoding: any depth, cmap ok"]
pub const L_FLATE_ENCODE: _bindgen_ty_19 = 3;
#[doc = "< use jp2k encoding: 8 and 32 bpp, no cmap"]
pub const L_JP2K_ENCODE: _bindgen_ty_19 = 4;
#[doc = " Pdf Encoding"]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[doc = " Compressed image data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Compressed_Data {
    #[doc = "< encoding type: L_JPEG_ENCODE, etc"]
    pub type_: l_int32,
    #[doc = "< gzipped raster data"]
    pub datacomp: *mut l_uint8,
    #[doc = "< number of compressed bytes"]
    pub nbytescomp: usize,
    #[doc = "< ascii85-encoded gzipped raster data"]
    pub data85: *mut ::std::os::raw::c_char,
    #[doc = "< number of ascii85 encoded bytes"]
    pub nbytes85: usize,
    #[doc = "< ascii85-encoded uncompressed cmap"]
    pub cmapdata85: *mut ::std::os::raw::c_char,
    #[doc = "< hex pdf array for the cmap"]
    pub cmapdatahex: *mut ::std::os::raw::c_char,
    #[doc = "< number of colors in cmap"]
    pub ncolors: l_int32,
    #[doc = "< image width"]
    pub w: l_int32,
    #[doc = "< image height"]
    pub h: l_int32,
    #[doc = "< bits/sample; typ. 1, 2, 4 or 8"]
    pub bps: l_int32,
    #[doc = "< samples/pixel; typ. 1 or 3"]
    pub spp: l_int32,
    #[doc = "< tiff g4 photometry"]
    pub minisblack: l_int32,
    #[doc = "< flate data has PNG predictors"]
    pub predictor: l_int32,
    #[doc = "< number of uncompressed raster bytes"]
    pub nbytes: usize,
    #[doc = "< resolution (ppi)"]
    pub res: l_int32,
}
#[test]
fn bindgen_test_layout_L_Compressed_Data() {
    const UNINIT: ::std::mem::MaybeUninit<L_Compressed_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Compressed_Data>(),
        104usize,
        concat!("Size of: ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Compressed_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).datacomp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(datacomp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytescomp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytescomp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data85) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(data85)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes85) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes85)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmapdata85) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdata85)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmapdatahex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdatahex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncolors) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bps) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spp) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(spp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minisblack) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(minisblack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).predictor) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(predictor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(res)
        )
    );
}
#[doc = " Compressed image data"]
pub type L_COMP_DATA = L_Compressed_Data;
#[doc = "< first image to be used"]
pub const L_FIRST_IMAGE: _bindgen_ty_20 = 1;
#[doc = "< intermediate image; not first or last"]
pub const L_NEXT_IMAGE: _bindgen_ty_20 = 2;
#[doc = "< last image to be used"]
pub const L_LAST_IMAGE: _bindgen_ty_20 = 3;
#[doc = " Pdf MultiImage"]
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[doc = " Intermediate pdf generation data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Pdf_Data {
    #[doc = "< optional title for pdf"]
    pub title: *mut ::std::os::raw::c_char,
    #[doc = "< number of images"]
    pub n: l_int32,
    #[doc = "< number of colormaps"]
    pub ncmap: l_int32,
    #[doc = "< array of compressed image data"]
    pub cida: *mut L_Ptra,
    #[doc = "< %PDF-1.2 id string"]
    pub id: *mut ::std::os::raw::c_char,
    #[doc = "< catalog string"]
    pub obj1: *mut ::std::os::raw::c_char,
    #[doc = "< metadata string"]
    pub obj2: *mut ::std::os::raw::c_char,
    #[doc = "< pages string"]
    pub obj3: *mut ::std::os::raw::c_char,
    #[doc = "< page string (variable data)"]
    pub obj4: *mut ::std::os::raw::c_char,
    #[doc = "< content string (variable data)"]
    pub obj5: *mut ::std::os::raw::c_char,
    #[doc = "< post-binary-stream string"]
    pub poststream: *mut ::std::os::raw::c_char,
    #[doc = "< trailer string (variable data)"]
    pub trailer: *mut ::std::os::raw::c_char,
    #[doc = "< store (xpt, ypt) array"]
    pub xy: *mut Pta,
    #[doc = "< store (wpt, hpt) array"]
    pub wh: *mut Pta,
    #[doc = "< bounding region for all images"]
    pub mediabox: *mut Box,
    #[doc = "< pre-binary-stream xobject strings"]
    pub saprex: *mut Sarray,
    #[doc = "< colormap pdf object strings"]
    pub sacmap: *mut Sarray,
    #[doc = "< sizes of each pdf string object"]
    pub objsize: *mut L_Dna,
    #[doc = "< location of each pdf string object"]
    pub objloc: *mut L_Dna,
    #[doc = "< location of xref"]
    pub xrefloc: l_int32,
}
#[test]
fn bindgen_test_layout_L_Pdf_Data() {
    const UNINIT: ::std::mem::MaybeUninit<L_Pdf_Data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Pdf_Data>(),
        152usize,
        concat!("Size of: ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Pdf_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ncmap) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(ncmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cida) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(cida)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj3) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj4) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).obj5) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poststream) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(poststream)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trailer) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(trailer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xy) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wh) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(wh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mediabox) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(mediabox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saprex) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(saprex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sacmap) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(sacmap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objsize) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).objloc) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xrefloc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xrefloc)
        )
    );
}
#[doc = " Intermediate pdf generation data"]
pub type L_PDF_DATA = L_Pdf_Data;
#[doc = " <pre>\n The JbClasser struct holds all the data accumulated during the\n classification process that can be used for a compressed\n jbig2-type representation of a set of images.  This is created\n in an initialization process and added to as the selected components\n on each successive page are analyzed.\n </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbClasser {
    #[doc = "< input page image file names"]
    pub safiles: *mut Sarray,
    #[doc = "< JB_RANKHAUS, JB_CORRELATION"]
    pub method: l_int32,
    #[doc = "< JB_CONN_COMPS, JB_CHARACTERS or      */\n/*!< JB_WORDS"]
    pub components: l_int32,
    #[doc = "< max component width allowed"]
    pub maxwidth: l_int32,
    #[doc = "< max component height allowed"]
    pub maxheight: l_int32,
    #[doc = "< number of pages already processed"]
    pub npages: l_int32,
    #[doc = "< number components already processed  */\n/*!< on fully processed pages"]
    pub baseindex: l_int32,
    #[doc = "< number of components on each page"]
    pub nacomps: *mut Numa,
    #[doc = "< size of square struct elem for haus"]
    pub sizehaus: l_int32,
    #[doc = "< rank val of haus match, each way"]
    pub rankhaus: l_float32,
    #[doc = "< thresh value for correlation score"]
    pub thresh: l_float32,
    #[doc = "< corrects thresh value for heaver     */\n/*!< components; use 0 for no correction"]
    pub weightfactor: l_float32,
    #[doc = "< w * h of each template, without      */\n/*!< extra border pixels"]
    pub naarea: *mut Numa,
    #[doc = "< max width of original src images"]
    pub w: l_int32,
    #[doc = "< max height of original src images"]
    pub h: l_int32,
    #[doc = "< current number of classes"]
    pub nclass: l_int32,
    #[doc = "< If zero, pixaa isn't filled"]
    pub keep_pixaa: l_int32,
    #[doc = "< instances for each class; unbordered"]
    pub pixaa: *mut Pixaa,
    #[doc = "< templates for each class; bordered   */\n/*!< and not dilated"]
    pub pixat: *mut Pixa,
    #[doc = "< templates for each class; bordered   */\n/*!< and dilated"]
    pub pixatd: *mut Pixa,
    #[doc = "< Hash table to find templates by size"]
    pub dahash: *mut L_DnaHash,
    #[doc = "< fg areas of undilated templates;     */\n/*!< only used for rank < 1.0"]
    pub nafgt: *mut Numa,
    #[doc = "< centroids of all bordered cc"]
    pub ptac: *mut Pta,
    #[doc = "< centroids of all bordered template cc"]
    pub ptact: *mut Pta,
    #[doc = "< array of class ids for each component"]
    pub naclass: *mut Numa,
    #[doc = "< array of page nums for each component"]
    pub napage: *mut Numa,
    #[doc = "< array of UL corners at which the     */\n/*!< template is to be placed for each    */\n/*!< component"]
    pub ptaul: *mut Pta,
    #[doc = "< similar to ptaul, but for LL corners"]
    pub ptall: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbClasser() {
    const UNINIT: ::std::mem::MaybeUninit<JbClasser> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JbClasser>(),
        168usize,
        concat!("Size of: ", stringify!(JbClasser))
    );
    assert_eq!(
        ::std::mem::align_of::<JbClasser>(),
        8usize,
        concat!("Alignment of ", stringify!(JbClasser))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).safiles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(safiles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).method) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).components) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxwidth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxheight) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxheight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npages) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).baseindex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(baseindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nacomps) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nacomps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sizehaus) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(sizehaus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rankhaus) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(rankhaus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thresh) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).weightfactor) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(weightfactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naarea) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naarea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nclass) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keep_pixaa) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(keep_pixaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixaa) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixat) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixatd) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixatd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dahash) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(dahash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nafgt) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nafgt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptac) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptact) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptact)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naclass) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).napage) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptaul) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptaul)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptall) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptall)
        )
    );
}
#[doc = " <pre>\n The JbClasser struct holds all the data accumulated during the\n classification process that can be used for a compressed\n jbig2-type representation of a set of images.  This is created\n in an initialization process and added to as the selected components\n on each successive page are analyzed.\n </pre>"]
pub type JBCLASSER = JbClasser;
#[doc = " <pre>\n The JbData struct holds all the data required for\n the compressed jbig-type representation of a set of images.\n The data can be written to file, read back, and used\n to regenerate an approximate version of the original,\n which differs in two ways from the original:\n   (1) It uses a template image for each c.c. instead of the\n       original instance, for each occurrence on each page.\n   (2) It discards components with either a height or width larger\n       than the maximuma, given here by the lattice dimensions\n       used for storing the templates.\n </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbData {
    #[doc = "< template composite for all classes"]
    pub pix: *mut Pix,
    #[doc = "< number of pages"]
    pub npages: l_int32,
    #[doc = "< max width of original page images"]
    pub w: l_int32,
    #[doc = "< max height of original page images"]
    pub h: l_int32,
    #[doc = "< number of classes"]
    pub nclass: l_int32,
    #[doc = "< lattice width for template composite"]
    pub latticew: l_int32,
    #[doc = "< lattice height for template composite"]
    pub latticeh: l_int32,
    #[doc = "< array of class ids for each component"]
    pub naclass: *mut Numa,
    #[doc = "< array of page nums for each component"]
    pub napage: *mut Numa,
    #[doc = "< array of UL corners at which the      */\n/*!< template is to be placed for each     */\n/*!< component"]
    pub ptaul: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbData() {
    const UNINIT: ::std::mem::MaybeUninit<JbData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<JbData>(),
        56usize,
        concat!("Size of: ", stringify!(JbData))
    );
    assert_eq!(
        ::std::mem::align_of::<JbData>(),
        8usize,
        concat!("Alignment of ", stringify!(JbData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pix) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nclass) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latticew) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).latticeh) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticeh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naclass) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).napage) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptaul) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(ptaul)
        )
    );
}
#[doc = " <pre>\n The JbData struct holds all the data required for\n the compressed jbig-type representation of a set of images.\n The data can be written to file, read back, and used\n to regenerate an approximate version of the original,\n which differs in two ways from the original:\n   (1) It uses a template image for each c.c. instead of the\n       original instance, for each occurrence on each page.\n   (2) It discards components with either a height or width larger\n       than the maximuma, given here by the lattice dimensions\n       used for storing the templates.\n </pre>"]
pub type JBDATA = JbData;
pub const JB_RANKHAUS: _bindgen_ty_21 = 0;
pub const JB_CORRELATION: _bindgen_ty_21 = 1;
#[doc = " JB Classifier"]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const JB_CONN_COMPS: _bindgen_ty_22 = 0;
pub const JB_CHARACTERS: _bindgen_ty_22 = 1;
pub const JB_WORDS: _bindgen_ty_22 = 2;
#[doc = " For jbGetComponents(): type of component to extract from images */\n/*! JB Component"]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[doc = " Selection"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sel {
    #[doc = "< sel height"]
    pub sy: l_int32,
    #[doc = "< sel width"]
    pub sx: l_int32,
    #[doc = "< y location of sel origin"]
    pub cy: l_int32,
    #[doc = "< x location of sel origin"]
    pub cx: l_int32,
    #[doc = "< {0,1,2}; data[i][j] in [row][col] order"]
    pub data: *mut *mut l_int32,
    #[doc = "< used to find sel by name"]
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sel() {
    const UNINIT: ::std::mem::MaybeUninit<Sel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Sel>(),
        32usize,
        concat!("Size of: ", stringify!(Sel))
    );
    assert_eq!(
        ::std::mem::align_of::<Sel>(),
        8usize,
        concat!("Alignment of ", stringify!(Sel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cy))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cx))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(name))
    );
}
#[doc = " Selection"]
pub type SEL = Sel;
#[doc = " Array of Sel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sela {
    #[doc = "< number of sel actually stored"]
    pub n: l_int32,
    #[doc = "< size of allocated ptr array"]
    pub nalloc: l_int32,
    #[doc = "< sel ptr array"]
    pub sel: *mut *mut Sel,
}
#[test]
fn bindgen_test_layout_Sela() {
    const UNINIT: ::std::mem::MaybeUninit<Sela> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Sela>(),
        16usize,
        concat!("Size of: ", stringify!(Sela))
    );
    assert_eq!(
        ::std::mem::align_of::<Sela>(),
        8usize,
        concat!("Alignment of ", stringify!(Sela))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalloc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Sela),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sel) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(sel))
    );
}
#[doc = " Array of Sel"]
pub type SELA = Sela;
#[doc = " Kernel"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Kernel {
    #[doc = "< kernel height"]
    pub sy: l_int32,
    #[doc = "< kernel width"]
    pub sx: l_int32,
    #[doc = "< y location of kernel origin"]
    pub cy: l_int32,
    #[doc = "< x location of kernel origin"]
    pub cx: l_int32,
    #[doc = "< data[i][j] in [row][col] order"]
    pub data: *mut *mut l_float32,
}
#[test]
fn bindgen_test_layout_L_Kernel() {
    const UNINIT: ::std::mem::MaybeUninit<L_Kernel> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Kernel>(),
        24usize,
        concat!("Size of: ", stringify!(L_Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Kernel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Kernel"]
pub type L_KERNEL = L_Kernel;
pub const SYMMETRIC_MORPH_BC: _bindgen_ty_23 = 0;
pub const ASYMMETRIC_MORPH_BC: _bindgen_ty_23 = 1;
#[doc = " Morph Boundary"]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const SEL_DONT_CARE: _bindgen_ty_24 = 0;
pub const SEL_HIT: _bindgen_ty_24 = 1;
pub const SEL_MISS: _bindgen_ty_24 = 2;
#[doc = " SEL Vals"]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const L_RUN_OFF: _bindgen_ty_25 = 0;
pub const L_RUN_ON: _bindgen_ty_25 = 1;
#[doc = " Runlength Polarity"]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const L_HORIZ: _bindgen_ty_26 = 1;
pub const L_VERT: _bindgen_ty_26 = 2;
pub const L_BOTH_DIRECTIONS: _bindgen_ty_26 = 3;
#[doc = " Direction Flags"]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const L_MORPH_DILATE: _bindgen_ty_27 = 1;
pub const L_MORPH_ERODE: _bindgen_ty_27 = 2;
pub const L_MORPH_OPEN: _bindgen_ty_27 = 3;
pub const L_MORPH_CLOSE: _bindgen_ty_27 = 4;
pub const L_MORPH_HMT: _bindgen_ty_27 = 5;
#[doc = " Morph Operator"]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const L_LINEAR_SCALE: _bindgen_ty_28 = 1;
pub const L_LOG_SCALE: _bindgen_ty_28 = 2;
#[doc = " Pixel Value Scaling"]
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const L_TOPHAT_WHITE: _bindgen_ty_29 = 0;
pub const L_TOPHAT_BLACK: _bindgen_ty_29 = 1;
#[doc = " Morph Tophat"]
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const L_ARITH_ADD: _bindgen_ty_30 = 1;
pub const L_ARITH_SUBTRACT: _bindgen_ty_30 = 2;
pub const L_ARITH_MULTIPLY: _bindgen_ty_30 = 3;
pub const L_ARITH_DIVIDE: _bindgen_ty_30 = 4;
pub const L_UNION: _bindgen_ty_30 = 5;
pub const L_INTERSECTION: _bindgen_ty_30 = 6;
pub const L_SUBTRACTION: _bindgen_ty_30 = 7;
pub const L_EXCLUSIVE_OR: _bindgen_ty_30 = 8;
#[doc = " ArithLogical Ops"]
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const L_CHOOSE_MIN: _bindgen_ty_31 = 1;
pub const L_CHOOSE_MAX: _bindgen_ty_31 = 2;
pub const L_CHOOSE_MAXDIFF: _bindgen_ty_31 = 3;
pub const L_CHOOSE_MIN_BOOST: _bindgen_ty_31 = 4;
pub const L_CHOOSE_MAX_BOOST: _bindgen_ty_31 = 5;
#[doc = " MinMax Selection"]
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const L_BOUNDARY_BG: _bindgen_ty_32 = 1;
pub const L_BOUNDARY_FG: _bindgen_ty_32 = 2;
#[doc = " Exterior Value"]
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const L_COMPARE_XOR: _bindgen_ty_33 = 1;
pub const L_COMPARE_SUBTRACT: _bindgen_ty_33 = 2;
pub const L_COMPARE_ABS_DIFF: _bindgen_ty_33 = 3;
#[doc = " Image Comparison"]
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
#[doc = "< pixels, not bits"]
pub const ADDED_BORDER: l_int32 = 32;
#[doc = " Basic Pix"]
pub type PIX = Pix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixColormap {
    _unused: [u8; 0],
}
#[doc = " Colormap of a Pix"]
pub type PIXCMAP = PixColormap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBA_Quad {
    _unused: [u8; 0],
}
#[doc = " Colormap table entry (after the BMP version).\n Note that the BMP format stores the colormap table exactly\n as it appears here, with color samples being stored sequentially,\n in the order (b,g,r,a)."]
pub type RGBA_QUAD = RGBA_Quad;
#[doc = " Array of pix"]
pub type PIXA = Pixa;
#[doc = " Array of arrays of pix"]
pub type PIXAA = Pixaa;
#[doc = " Basic rectangle"]
pub type BOX = Box;
#[doc = " Array of Box"]
pub type BOXA = Boxa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxaa {
    _unused: [u8; 0],
}
#[doc = " Array of Boxa"]
pub type BOXAA = Boxaa;
#[doc = " Array of points"]
pub type PTA = Pta;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ptaa {
    _unused: [u8; 0],
}
#[doc = " Array of Pta"]
pub type PTAA = Ptaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixacc {
    _unused: [u8; 0],
}
#[doc = " Pix accumulator container"]
pub type PIXACC = Pixacc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixTiling {
    _unused: [u8; 0],
}
#[doc = " Pix tiling"]
pub type PIXTILING = PixTiling;
#[doc = " Pix with float array"]
pub type FPIX = FPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPixa {
    _unused: [u8; 0],
}
#[doc = " Array of FPix"]
pub type FPIXA = FPixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPix {
    _unused: [u8; 0],
}
#[doc = " Pix with double array"]
pub type DPIX = DPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixComp {
    _unused: [u8; 0],
}
#[doc = " Compressed Pix"]
pub type PIXC = PixComp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixaComp {
    _unused: [u8; 0],
}
#[doc = " Array of compressed pix"]
pub type PIXAC = PixaComp;
#[doc = "< red color index in RGBA_QUAD"]
pub const COLOR_RED: _bindgen_ty_34 = 0;
#[doc = "< green color index in RGBA_QUAD"]
pub const COLOR_GREEN: _bindgen_ty_34 = 1;
#[doc = "< blue color index in RGBA_QUAD"]
pub const COLOR_BLUE: _bindgen_ty_34 = 2;
#[doc = "< alpha value index in RGBA_QUAD"]
pub const L_ALPHA_CHANNEL: _bindgen_ty_34 = 3;
#[doc = " RGBA Color"]
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const L_RED_SHIFT: l_int32 = 24;
pub const L_GREEN_SHIFT: l_int32 = 16;
pub const L_BLUE_SHIFT: l_int32 = 8;
pub const L_ALPHA_SHIFT: l_int32 = 0;
#[doc = "< draw in red"]
pub const L_DRAW_RED: _bindgen_ty_35 = 0;
#[doc = "< draw in green"]
pub const L_DRAW_GREEN: _bindgen_ty_35 = 1;
#[doc = "< draw in blue"]
pub const L_DRAW_BLUE: _bindgen_ty_35 = 2;
#[doc = "< draw specified color"]
pub const L_DRAW_SPECIFIED: _bindgen_ty_35 = 3;
#[doc = "< draw as sequence of r,g,b"]
pub const L_DRAW_RGB: _bindgen_ty_35 = 4;
#[doc = "< draw randomly chosen colors"]
pub const L_DRAW_RANDOM: _bindgen_ty_35 = 5;
#[doc = " Box Color"]
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
#[doc = "< Percept. weight for red"]
pub const L_RED_WEIGHT: l_float32 = 0.30000001192092896;
#[doc = "< Percept. weight for green"]
pub const L_GREEN_WEIGHT: l_float32 = 0.5;
#[doc = "< Percept. weight for blue"]
pub const L_BLUE_WEIGHT: l_float32 = 0.20000000298023224;
#[doc = "< remove colormap for conv to 1 bpp"]
pub const REMOVE_CMAP_TO_BINARY: _bindgen_ty_36 = 0;
#[doc = "< remove colormap for conv to 8 bpp"]
pub const REMOVE_CMAP_TO_GRAYSCALE: _bindgen_ty_36 = 1;
#[doc = "< remove colormap for conv to 32 bpp"]
pub const REMOVE_CMAP_TO_FULL_COLOR: _bindgen_ty_36 = 2;
#[doc = "< remove colormap and alpha"]
pub const REMOVE_CMAP_WITH_ALPHA: _bindgen_ty_36 = 3;
#[doc = "< remove depending on src format"]
pub const REMOVE_CMAP_BASED_ON_SRC: _bindgen_ty_36 = 4;
#[doc = " Cmap Conversion"]
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
#[doc = "< do not copy the object; do not delete the ptr"]
pub const L_NOCOPY: _bindgen_ty_37 = 0;
#[doc = "< stuff it in; do not copy or clone"]
pub const L_INSERT: _bindgen_ty_37 = 0;
#[doc = "< make/use a copy of the object"]
pub const L_COPY: _bindgen_ty_37 = 1;
#[doc = "< make/use clone (ref count) of the object"]
pub const L_CLONE: _bindgen_ty_37 = 2;
#[doc = "< make a new array object (e.g., pixa) and fill  */\n/*!< the array with clones (e.g., pix)"]
pub const L_COPY_CLONE: _bindgen_ty_37 = 3;
#[doc = " Object Access"]
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
#[doc = "< use shell sort"]
pub const L_SHELL_SORT: _bindgen_ty_38 = 1;
#[doc = "< use bin sort"]
pub const L_BIN_SORT: _bindgen_ty_38 = 2;
#[doc = " Sort Mode"]
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
#[doc = "< sort in increasing order"]
pub const L_SORT_INCREASING: _bindgen_ty_39 = 1;
#[doc = "< sort in decreasing order"]
pub const L_SORT_DECREASING: _bindgen_ty_39 = 2;
#[doc = " Sort Order"]
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
#[doc = "< sort box or c.c. by left edge location"]
pub const L_SORT_BY_X: _bindgen_ty_40 = 1;
#[doc = "< sort box or c.c. by top edge location"]
pub const L_SORT_BY_Y: _bindgen_ty_40 = 2;
#[doc = "< sort box or c.c. by right edge location"]
pub const L_SORT_BY_RIGHT: _bindgen_ty_40 = 3;
#[doc = "< sort box or c.c. by bot edge location"]
pub const L_SORT_BY_BOT: _bindgen_ty_40 = 4;
#[doc = "< sort box or c.c. by width"]
pub const L_SORT_BY_WIDTH: _bindgen_ty_40 = 5;
#[doc = "< sort box or c.c. by height"]
pub const L_SORT_BY_HEIGHT: _bindgen_ty_40 = 6;
#[doc = "< sort box or c.c. by min dimension"]
pub const L_SORT_BY_MIN_DIMENSION: _bindgen_ty_40 = 7;
#[doc = "< sort box or c.c. by max dimension"]
pub const L_SORT_BY_MAX_DIMENSION: _bindgen_ty_40 = 8;
#[doc = "< sort box or c.c. by perimeter"]
pub const L_SORT_BY_PERIMETER: _bindgen_ty_40 = 9;
#[doc = "< sort box or c.c. by area"]
pub const L_SORT_BY_AREA: _bindgen_ty_40 = 10;
#[doc = "< sort box or c.c. by width/height ratio"]
pub const L_SORT_BY_ASPECT_RATIO: _bindgen_ty_40 = 11;
#[doc = " Sort Type"]
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
#[doc = "< add some of src inverse to itself"]
pub const L_BLEND_WITH_INVERSE: _bindgen_ty_41 = 1;
#[doc = "< shift src colors towards white"]
pub const L_BLEND_TO_WHITE: _bindgen_ty_41 = 2;
#[doc = "< shift src colors towards black"]
pub const L_BLEND_TO_BLACK: _bindgen_ty_41 = 3;
#[doc = "< blend src directly with blender"]
pub const L_BLEND_GRAY: _bindgen_ty_41 = 4;
#[doc = "< add amount of src inverse to itself,  */\n/*!< based on blender pix value"]
pub const L_BLEND_GRAY_WITH_INVERSE: _bindgen_ty_41 = 5;
#[doc = " Blend Types"]
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
#[doc = "< colorize non-black pixels"]
pub const L_PAINT_LIGHT: _bindgen_ty_42 = 1;
#[doc = "< colorize non-white pixels"]
pub const L_PAINT_DARK: _bindgen_ty_42 = 2;
#[doc = " Paint Selection"]
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
#[doc = "< set all bits in each pixel to 1"]
pub const L_SET_PIXELS: _bindgen_ty_43 = 1;
#[doc = "< set all bits in each pixel to 0"]
pub const L_CLEAR_PIXELS: _bindgen_ty_43 = 2;
#[doc = "< flip all bits in each pixel"]
pub const L_FLIP_PIXELS: _bindgen_ty_43 = 3;
#[doc = " Pixel Setting"]
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
#[doc = "< save if value is less than threshold"]
pub const L_SELECT_IF_LT: _bindgen_ty_44 = 1;
#[doc = "< save if value is more than threshold"]
pub const L_SELECT_IF_GT: _bindgen_ty_44 = 2;
#[doc = "< save if value is <= to the threshold"]
pub const L_SELECT_IF_LTE: _bindgen_ty_44 = 3;
#[doc = "< save if value is >= to the threshold"]
pub const L_SELECT_IF_GTE: _bindgen_ty_44 = 4;
#[doc = " Size Comparison"]
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
#[doc = "< select by width; 1 bpp"]
pub const L_SELECT_BY_WIDTH: _bindgen_ty_45 = 1;
#[doc = "< select by height; 1 bpp"]
pub const L_SELECT_BY_HEIGHT: _bindgen_ty_45 = 2;
#[doc = "< select by max of width and        */\n/*!< height; 1 bpp"]
pub const L_SELECT_BY_MAX_DIMENSION: _bindgen_ty_45 = 3;
#[doc = "< select by foreground area; 1 bpp"]
pub const L_SELECT_BY_AREA: _bindgen_ty_45 = 4;
#[doc = "< select by perimeter; 1 bpp"]
pub const L_SELECT_BY_PERIMETER: _bindgen_ty_45 = 5;
#[doc = " Size Selection"]
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
#[doc = "< width must satisfy constraint"]
pub const L_SELECT_WIDTH: _bindgen_ty_46 = 1;
#[doc = "< height must satisfy constraint"]
pub const L_SELECT_HEIGHT: _bindgen_ty_46 = 2;
#[doc = "< x value must satisfy constraint"]
pub const L_SELECT_XVAL: _bindgen_ty_46 = 3;
#[doc = "< y value must satisfy constraint"]
pub const L_SELECT_YVAL: _bindgen_ty_46 = 4;
#[doc = "< either width or height (or xval       */\n/*!< or yval) can satisfy constraint"]
pub const L_SELECT_IF_EITHER: _bindgen_ty_46 = 5;
#[doc = "< both width and height (or xval        */\n/*!< and yval must satisfy constraint"]
pub const L_SELECT_IF_BOTH: _bindgen_ty_46 = 6;
#[doc = " Location Filter"]
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
#[doc = "< check and possibly modify width"]
pub const L_CHECK_WIDTH: _bindgen_ty_47 = 1;
#[doc = "< check and possibly modify height"]
pub const L_CHECK_HEIGHT: _bindgen_ty_47 = 2;
#[doc = "< check and possibly modify both"]
pub const L_CHECK_BOTH: _bindgen_ty_47 = 3;
#[doc = " Boxa Check"]
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
#[doc = "< use red component"]
pub const L_SELECT_RED: _bindgen_ty_48 = 1;
#[doc = "< use green component"]
pub const L_SELECT_GREEN: _bindgen_ty_48 = 2;
#[doc = "< use blue component"]
pub const L_SELECT_BLUE: _bindgen_ty_48 = 3;
#[doc = "< use min color component"]
pub const L_SELECT_MIN: _bindgen_ty_48 = 4;
#[doc = "< use max color component"]
pub const L_SELECT_MAX: _bindgen_ty_48 = 5;
#[doc = "< use average of color components"]
pub const L_SELECT_AVERAGE: _bindgen_ty_48 = 6;
#[doc = "< use hue value (in HSV color space)"]
pub const L_SELECT_HUE: _bindgen_ty_48 = 7;
#[doc = "< use saturation value (in HSV space)"]
pub const L_SELECT_SATURATION: _bindgen_ty_48 = 8;
#[doc = "< use weighted average of color comps"]
pub const L_SELECT_WEIGHTED: _bindgen_ty_48 = 9;
#[doc = " Color Selection"]
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
#[doc = "< intermediate of diff component values"]
pub const L_INTERMED_DIFF: _bindgen_ty_49 = 1;
#[doc = "< diff average closest comps to third"]
pub const L_AVE_MAX_DIFF_2: _bindgen_ty_49 = 2;
#[doc = "< maximum diff of component values"]
pub const L_MAX_DIFF: _bindgen_ty_49 = 3;
#[doc = " Color Content"]
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
#[doc = "< use LSB"]
pub const L_LS_BYTE: _bindgen_ty_50 = 1;
#[doc = "< use MSB"]
pub const L_MS_BYTE: _bindgen_ty_50 = 2;
#[doc = "< use LSB if max(val) < 256; else MSB"]
pub const L_AUTO_BYTE: _bindgen_ty_50 = 3;
#[doc = "< use max(val, 255)"]
pub const L_CLIP_TO_FF: _bindgen_ty_50 = 4;
#[doc = "< use two LSB"]
pub const L_LS_TWO_BYTES: _bindgen_ty_50 = 5;
#[doc = "< use two MSB"]
pub const L_MS_TWO_BYTES: _bindgen_ty_50 = 6;
#[doc = "< use max(val, 65535)"]
pub const L_CLIP_TO_FFFF: _bindgen_ty_50 = 7;
#[doc = " 16-bit Conversion"]
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
#[doc = "< use area map rotation, if possible"]
pub const L_ROTATE_AREA_MAP: _bindgen_ty_51 = 1;
#[doc = "< use shear rotation"]
pub const L_ROTATE_SHEAR: _bindgen_ty_51 = 2;
#[doc = "< use sampling"]
pub const L_ROTATE_SAMPLING: _bindgen_ty_51 = 3;
#[doc = " Rotation Type"]
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
#[doc = "< bring in white pixels from the outside"]
pub const L_BRING_IN_WHITE: _bindgen_ty_52 = 1;
#[doc = "< bring in black pixels from the outside"]
pub const L_BRING_IN_BLACK: _bindgen_ty_52 = 2;
#[doc = " Background Color"]
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
#[doc = "< shear image about UL corner"]
pub const L_SHEAR_ABOUT_CORNER: _bindgen_ty_53 = 1;
#[doc = "< shear image about center"]
pub const L_SHEAR_ABOUT_CENTER: _bindgen_ty_53 = 2;
#[doc = " Shear Point"]
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
#[doc = "< translate, scale, rotate"]
pub const L_TR_SC_RO: _bindgen_ty_54 = 1;
#[doc = "< scale, rotate, translate"]
pub const L_SC_RO_TR: _bindgen_ty_54 = 2;
#[doc = "< rotate, translate, scale"]
pub const L_RO_TR_SC: _bindgen_ty_54 = 3;
#[doc = "< translate, rotate, scale"]
pub const L_TR_RO_SC: _bindgen_ty_54 = 4;
#[doc = "< rotate, scale, translate"]
pub const L_RO_SC_TR: _bindgen_ty_54 = 5;
#[doc = "< scale, translate, rotate"]
pub const L_SC_TR_RO: _bindgen_ty_54 = 6;
#[doc = " Affine Transform Order"]
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
#[doc = "< fill white pixels (e.g, in fg map)"]
pub const L_FILL_WHITE: _bindgen_ty_55 = 1;
#[doc = "< fill black pixels (e.g., in bg map)"]
pub const L_FILL_BLACK: _bindgen_ty_55 = 2;
#[doc = " Grayscale Fill"]
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
#[doc = "< set pixels to white"]
pub const L_SET_WHITE: _bindgen_ty_56 = 1;
#[doc = "< set pixels to black"]
pub const L_SET_BLACK: _bindgen_ty_56 = 2;
#[doc = " BlackWhite Set"]
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
#[doc = "< get white pixel value"]
pub const L_GET_WHITE_VAL: _bindgen_ty_57 = 1;
#[doc = "< get black pixel value"]
pub const L_GET_BLACK_VAL: _bindgen_ty_57 = 2;
#[doc = " BlackWhite Get"]
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
#[doc = "< white pixels are 0xff or 0xffff; black are 0"]
pub const L_WHITE_IS_MAX: _bindgen_ty_58 = 1;
#[doc = "< black pixels are 0xff or 0xffff; white are 0"]
pub const L_BLACK_IS_MAX: _bindgen_ty_58 = 2;
#[doc = " BlackWhite Sum"]
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
#[doc = "< dist to black with no prop; 1 bpp"]
pub const DEFAULT_CLIP_LOWER_1: _bindgen_ty_59 = 10;
#[doc = "< dist to black with no prop; 1 bpp"]
pub const DEFAULT_CLIP_UPPER_1: _bindgen_ty_59 = 10;
#[doc = "< dist to black with no prop; 2 bpp"]
pub const DEFAULT_CLIP_LOWER_2: _bindgen_ty_59 = 5;
#[doc = "< dist to black with no prop; 2 bpp"]
pub const DEFAULT_CLIP_UPPER_2: _bindgen_ty_59 = 5;
#[doc = " Dither Distance"]
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
#[doc = "< L1 distance (e.g., in color space)"]
pub const L_MANHATTAN_DISTANCE: _bindgen_ty_60 = 1;
#[doc = "< L2 distance"]
pub const L_EUCLIDEAN_DISTANCE: _bindgen_ty_60 = 2;
#[doc = " Distance Type"]
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
#[doc = "< values < 0"]
pub const L_NEGATIVE: _bindgen_ty_61 = 1;
#[doc = "< values >= 0"]
pub const L_NON_NEGATIVE: _bindgen_ty_61 = 2;
#[doc = "< values > 0"]
pub const L_POSITIVE: _bindgen_ty_61 = 3;
#[doc = "< values <= 0"]
pub const L_NON_POSITIVE: _bindgen_ty_61 = 4;
#[doc = "< values = 0"]
pub const L_ZERO: _bindgen_ty_61 = 5;
#[doc = "< all values"]
pub const L_ALL: _bindgen_ty_61 = 6;
#[doc = " Distance Value"]
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
#[doc = "< average of abs values"]
pub const L_MEAN_ABSVAL: _bindgen_ty_62 = 1;
#[doc = "< median value of set"]
pub const L_MEDIAN_VAL: _bindgen_ty_62 = 2;
#[doc = "< mode value of set"]
pub const L_MODE_VAL: _bindgen_ty_62 = 3;
#[doc = "< mode count of set"]
pub const L_MODE_COUNT: _bindgen_ty_62 = 4;
#[doc = "< rms of values"]
pub const L_ROOT_MEAN_SQUARE: _bindgen_ty_62 = 5;
#[doc = "< standard deviation from mean"]
pub const L_STANDARD_DEVIATION: _bindgen_ty_62 = 6;
#[doc = "< variance of values"]
pub const L_VARIANCE: _bindgen_ty_62 = 7;
#[doc = " Stats Type"]
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
#[doc = "< select 'n' consecutive"]
pub const L_CHOOSE_CONSECUTIVE: _bindgen_ty_63 = 1;
#[doc = "< select at intervals of 'n'"]
pub const L_CHOOSE_SKIP_BY: _bindgen_ty_63 = 2;
#[doc = " Index Selection"]
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
#[doc = "< low confidence on text orientation"]
pub const L_TEXT_ORIENT_UNKNOWN: _bindgen_ty_64 = 0;
#[doc = "< portrait, text rightside-up"]
pub const L_TEXT_ORIENT_UP: _bindgen_ty_64 = 1;
#[doc = "< landscape, text up to left"]
pub const L_TEXT_ORIENT_LEFT: _bindgen_ty_64 = 2;
#[doc = "< portrait, text upside-down"]
pub const L_TEXT_ORIENT_DOWN: _bindgen_ty_64 = 3;
#[doc = "< landscape, text up to right"]
pub const L_TEXT_ORIENT_RIGHT: _bindgen_ty_64 = 4;
#[doc = " Text Orientation"]
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
#[doc = "< filters for horizontal edges"]
pub const L_HORIZONTAL_EDGES: _bindgen_ty_65 = 0;
#[doc = "< filters for vertical edges"]
pub const L_VERTICAL_EDGES: _bindgen_ty_65 = 1;
#[doc = "< filters for all edges"]
pub const L_ALL_EDGES: _bindgen_ty_65 = 2;
#[doc = " Edge Orientation"]
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
#[doc = "< horizontal line"]
pub const L_HORIZONTAL_LINE: _bindgen_ty_66 = 0;
#[doc = "< 45 degree line with positive slope"]
pub const L_POS_SLOPE_LINE: _bindgen_ty_66 = 1;
#[doc = "< vertical line"]
pub const L_VERTICAL_LINE: _bindgen_ty_66 = 2;
#[doc = "< 45 degree line with negative slope"]
pub const L_NEG_SLOPE_LINE: _bindgen_ty_66 = 3;
#[doc = "< neither horizontal nor vertical"]
pub const L_OBLIQUE_LINE: _bindgen_ty_66 = 4;
#[doc = " Line Orientation"]
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
#[doc = "< typical: page is viewed with height > width"]
pub const L_PORTRAIT_MODE: _bindgen_ty_67 = 0;
#[doc = "< page is viewed at 90 deg to portrait mode"]
pub const L_LANDSCAPE_MODE: _bindgen_ty_67 = 1;
#[doc = " Image Orientation"]
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
#[doc = "< scan from left"]
pub const L_FROM_LEFT: _bindgen_ty_68 = 0;
#[doc = "< scan from right"]
pub const L_FROM_RIGHT: _bindgen_ty_68 = 1;
#[doc = "< scan from top"]
pub const L_FROM_TOP: _bindgen_ty_68 = 2;
#[doc = "< scan from bottom"]
pub const L_FROM_BOT: _bindgen_ty_68 = 3;
#[doc = "< scan in negative direction"]
pub const L_SCAN_NEGATIVE: _bindgen_ty_68 = 4;
#[doc = "< scan in positive direction"]
pub const L_SCAN_POSITIVE: _bindgen_ty_68 = 5;
#[doc = "< scan in both directions"]
pub const L_SCAN_BOTH: _bindgen_ty_68 = 6;
#[doc = "< horizontal scan (direction unimportant)"]
pub const L_SCAN_HORIZONTAL: _bindgen_ty_68 = 7;
#[doc = "< vertical scan (direction unimportant)"]
pub const L_SCAN_VERTICAL: _bindgen_ty_68 = 8;
#[doc = " Scan Direction"]
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
#[doc = "< do not adjust"]
pub const L_ADJUST_SKIP: _bindgen_ty_69 = 0;
#[doc = "< adjust left edge"]
pub const L_ADJUST_LEFT: _bindgen_ty_69 = 1;
#[doc = "< adjust right edge"]
pub const L_ADJUST_RIGHT: _bindgen_ty_69 = 2;
#[doc = "< adjust both left and right edges"]
pub const L_ADJUST_LEFT_AND_RIGHT: _bindgen_ty_69 = 3;
#[doc = "< adjust top edge"]
pub const L_ADJUST_TOP: _bindgen_ty_69 = 4;
#[doc = "< adjust bottom edge"]
pub const L_ADJUST_BOT: _bindgen_ty_69 = 5;
#[doc = "< adjust both top and bottom edges"]
pub const L_ADJUST_TOP_AND_BOT: _bindgen_ty_69 = 6;
#[doc = "< choose the min median value"]
pub const L_ADJUST_CHOOSE_MIN: _bindgen_ty_69 = 7;
#[doc = "< choose the max median value"]
pub const L_ADJUST_CHOOSE_MAX: _bindgen_ty_69 = 8;
#[doc = "< set left side to a given value"]
pub const L_SET_LEFT: _bindgen_ty_69 = 9;
#[doc = "< set right side to a given value"]
pub const L_SET_RIGHT: _bindgen_ty_69 = 10;
#[doc = "< set top side to a given value"]
pub const L_SET_TOP: _bindgen_ty_69 = 11;
#[doc = "< set bottom side to a given value"]
pub const L_SET_BOT: _bindgen_ty_69 = 12;
#[doc = "< get left side location"]
pub const L_GET_LEFT: _bindgen_ty_69 = 13;
#[doc = "< get right side location"]
pub const L_GET_RIGHT: _bindgen_ty_69 = 14;
#[doc = "< get top side location"]
pub const L_GET_TOP: _bindgen_ty_69 = 15;
#[doc = "< get bottom side location"]
pub const L_GET_BOT: _bindgen_ty_69 = 16;
#[doc = " Box Adjustment"]
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
#[doc = "< use boundaries giving min size"]
pub const L_USE_MINSIZE: _bindgen_ty_70 = 1;
#[doc = "< use boundaries giving max size"]
pub const L_USE_MAXSIZE: _bindgen_ty_70 = 2;
#[doc = "< modify boundary if big location diff"]
pub const L_SUB_ON_LOC_DIFF: _bindgen_ty_70 = 3;
#[doc = "< modify boundary if big size diff"]
pub const L_SUB_ON_SIZE_DIFF: _bindgen_ty_70 = 4;
#[doc = "< modify boundary with capped min"]
pub const L_USE_CAPPED_MIN: _bindgen_ty_70 = 5;
#[doc = "< modify boundary with capped max"]
pub const L_USE_CAPPED_MAX: _bindgen_ty_70 = 6;
#[doc = " Box Boundary Mod"]
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
#[doc = "< resize to bounding region; remove smaller"]
pub const L_COMBINE: _bindgen_ty_71 = 1;
#[doc = "< only remove smaller"]
pub const L_REMOVE_SMALL: _bindgen_ty_71 = 2;
#[doc = " Box Overlap Mod"]
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
#[doc = "< use union of two boxes"]
pub const L_GEOMETRIC_UNION: _bindgen_ty_72 = 1;
#[doc = "< use intersection of two boxes"]
pub const L_GEOMETRIC_INTERSECTION: _bindgen_ty_72 = 2;
#[doc = "< use box with largest area"]
pub const L_LARGEST_AREA: _bindgen_ty_72 = 3;
#[doc = "< use box with smallest area"]
pub const L_SMALLEST_AREA: _bindgen_ty_72 = 4;
#[doc = " Box Combine or Select"]
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
#[doc = "< consider all boxes in the sequence"]
pub const L_USE_ALL_BOXES: _bindgen_ty_73 = 1;
#[doc = "< consider boxes with the same parity"]
pub const L_USE_SAME_PARITY_BOXES: _bindgen_ty_73 = 2;
#[doc = " Box Replacement"]
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
#[doc = "< UL corner"]
pub const L_UPPER_LEFT: _bindgen_ty_74 = 1;
#[doc = "< UR corner"]
pub const L_UPPER_RIGHT: _bindgen_ty_74 = 2;
#[doc = "< LL corner"]
pub const L_LOWER_LEFT: _bindgen_ty_74 = 3;
#[doc = "< LR corner"]
pub const L_LOWER_RIGHT: _bindgen_ty_74 = 4;
#[doc = "< center"]
pub const L_BOX_CENTER: _bindgen_ty_74 = 5;
#[doc = " Box Corners and Center"]
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
#[doc = "< increasing stretch or contraction to left"]
pub const L_WARP_TO_LEFT: _bindgen_ty_75 = 1;
#[doc = "< increasing stretch or contraction to right"]
pub const L_WARP_TO_RIGHT: _bindgen_ty_75 = 2;
#[doc = " Horiz Warp Stretch"]
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
#[doc = "< stretch or contraction grows linearly"]
pub const L_LINEAR_WARP: _bindgen_ty_76 = 1;
#[doc = "< stretch or contraction grows quadratically"]
pub const L_QUADRATIC_WARP: _bindgen_ty_76 = 2;
#[doc = " Horiz Warp Mode"]
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
#[doc = "< linear interpolation from src pixels"]
pub const L_INTERPOLATED: _bindgen_ty_77 = 1;
#[doc = "< nearest src pixel sampling only"]
pub const L_SAMPLED: _bindgen_ty_77 = 2;
#[doc = " Pixel Selection"]
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
#[doc = "< thin foreground of 1 bpp image"]
pub const L_THIN_FG: _bindgen_ty_78 = 1;
#[doc = "< thin background of 1 bpp image"]
pub const L_THIN_BG: _bindgen_ty_78 = 2;
#[doc = " Thinning Polarity"]
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
#[doc = "< determine runlengths of horizontal runs"]
pub const L_HORIZONTAL_RUNS: _bindgen_ty_79 = 0;
#[doc = "< determine runlengths of vertical runs"]
pub const L_VERTICAL_RUNS: _bindgen_ty_79 = 1;
#[doc = " Runlength Direction"]
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
#[doc = "< Sobel edge filter"]
pub const L_SOBEL_EDGE: _bindgen_ty_80 = 1;
#[doc = "< Two-sided edge filter"]
pub const L_TWO_SIDED_EDGE: _bindgen_ty_80 = 2;
#[doc = " Edge Filter"]
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
#[doc = "< sensor order left-to-right RGB"]
pub const L_SUBPIXEL_ORDER_RGB: _bindgen_ty_81 = 1;
#[doc = "< sensor order left-to-right BGR"]
pub const L_SUBPIXEL_ORDER_BGR: _bindgen_ty_81 = 2;
#[doc = "< sensor order top-to-bottom RGB"]
pub const L_SUBPIXEL_ORDER_VRGB: _bindgen_ty_81 = 3;
#[doc = "< sensor order top-to-bottom BGR"]
pub const L_SUBPIXEL_ORDER_VBGR: _bindgen_ty_81 = 4;
#[doc = " Subpixel Color Order"]
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
#[doc = "< Use hue-saturation histogram"]
pub const L_HS_HISTO: _bindgen_ty_82 = 1;
#[doc = "< Use hue-value histogram"]
pub const L_HV_HISTO: _bindgen_ty_82 = 2;
#[doc = "< Use saturation-value histogram"]
pub const L_SV_HISTO: _bindgen_ty_82 = 3;
#[doc = " HSV Histogram"]
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
#[doc = "< Use pixels with specified HSV region"]
pub const L_INCLUDE_REGION: _bindgen_ty_83 = 1;
#[doc = "< Use pixels outside HSV region"]
pub const L_EXCLUDE_REGION: _bindgen_ty_83 = 2;
#[doc = " HSV Region"]
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
#[doc = "< Add text above the image"]
pub const L_ADD_ABOVE: _bindgen_ty_84 = 1;
#[doc = "< Add text below the image"]
pub const L_ADD_BELOW: _bindgen_ty_84 = 2;
#[doc = "< Add text to the left of the image"]
pub const L_ADD_LEFT: _bindgen_ty_84 = 3;
#[doc = "< Add text to the right of the image"]
pub const L_ADD_RIGHT: _bindgen_ty_84 = 4;
#[doc = "< Add text over the top of the image"]
pub const L_ADD_AT_TOP: _bindgen_ty_84 = 5;
#[doc = "< Add text over the bottom of the image"]
pub const L_ADD_AT_BOT: _bindgen_ty_84 = 6;
#[doc = "< Add text over left side of the image"]
pub const L_ADD_AT_LEFT: _bindgen_ty_84 = 7;
#[doc = "< Add text over right side of the image"]
pub const L_ADD_AT_RIGHT: _bindgen_ty_84 = 8;
#[doc = " Add Text Location"]
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
#[doc = "< Plot horizontally at top"]
pub const L_PLOT_AT_TOP: _bindgen_ty_85 = 1;
#[doc = "< Plot horizontally at middle"]
pub const L_PLOT_AT_MID_HORIZ: _bindgen_ty_85 = 2;
#[doc = "< Plot horizontally at bottom"]
pub const L_PLOT_AT_BOT: _bindgen_ty_85 = 3;
#[doc = "< Plot vertically at left"]
pub const L_PLOT_AT_LEFT: _bindgen_ty_85 = 4;
#[doc = "< Plot vertically at middle"]
pub const L_PLOT_AT_MID_VERT: _bindgen_ty_85 = 5;
#[doc = "< Plot vertically at right"]
pub const L_PLOT_AT_RIGHT: _bindgen_ty_85 = 6;
#[doc = " Pix Plot"]
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
#[doc = "< Select the interior part"]
pub const L_USE_INNER: _bindgen_ty_86 = 1;
#[doc = "< Select the outer part (e.g., a frame)"]
pub const L_USE_OUTER: _bindgen_ty_86 = 2;
#[doc = " Mask Generation"]
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
#[doc = "< Use xzgv with pixDisplay()"]
pub const L_DISPLAY_WITH_XZGV: _bindgen_ty_87 = 1;
#[doc = "< Use xli with pixDisplay()"]
pub const L_DISPLAY_WITH_XLI: _bindgen_ty_87 = 2;
#[doc = "< Use xv with pixDisplay()"]
pub const L_DISPLAY_WITH_XV: _bindgen_ty_87 = 3;
#[doc = "< Use irfvanview (win) with pixDisplay()"]
pub const L_DISPLAY_WITH_IV: _bindgen_ty_87 = 4;
#[doc = "< Use open (apple) with pixDisplay()"]
pub const L_DISPLAY_WITH_OPEN: _bindgen_ty_87 = 5;
#[doc = " Display Program"]
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
#[doc = "< Write full resolution chroma"]
pub const L_NO_CHROMA_SAMPLING_JPEG: _bindgen_ty_88 = 1;
#[doc = " Flags used in Pix::special"]
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
#[doc = "< Clip negative values to 0"]
pub const L_CLIP_TO_ZERO: _bindgen_ty_89 = 1;
#[doc = "< Convert to positive using L_ABS()"]
pub const L_TAKE_ABSVAL: _bindgen_ty_89 = 2;
#[doc = " Negative Value"]
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
#[doc = "< Choose values less than zero"]
pub const L_LESS_THAN_ZERO: _bindgen_ty_90 = 1;
#[doc = "< Choose values equal to zero"]
pub const L_EQUAL_TO_ZERO: _bindgen_ty_90 = 2;
#[doc = "< Choose values greater than zero"]
pub const L_GREATER_THAN_ZERO: _bindgen_ty_90 = 3;
#[doc = " Relative To Zero"]
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
#[doc = "< Add trailing slash to string"]
pub const L_ADD_TRAIL_SLASH: _bindgen_ty_91 = 1;
#[doc = "< Remove trailing slash from string"]
pub const L_REMOVE_TRAIL_SLASH: _bindgen_ty_91 = 2;
#[doc = " Trailing Slash"]
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
#[doc = " Allocator function type"]
pub type alloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void>;
#[doc = " Deallocator function type"]
pub type dealloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Recog {
    #[doc = "< scale all examples to this width;      */\n/*!< use 0 prevent horizontal scaling"]
    pub scalew: l_int32,
    #[doc = "< scale all examples to this height;     */\n/*!< use 0 prevent vertical scaling"]
    pub scaleh: l_int32,
    #[doc = "< use a value > 0 to convert the bitmap  */\n/*!< to lines of fixed width; 0 to skip"]
    pub linew: l_int32,
    #[doc = "< template use: use either the average   */\n/*!< or all temmplates (L_USE_AVERAGE or    */\n/*!< L_USE_ALL)"]
    pub templ_use: l_int32,
    #[doc = "< initialize container arrays to this"]
    pub maxarraysize: l_int32,
    #[doc = "< size of character set"]
    pub setsize: l_int32,
    #[doc = "< for binarizing if depth > 1"]
    pub threshold: l_int32,
    #[doc = "< vertical jiggle on nominal centroid    */\n/*!< alignment; typically 0 or 1"]
    pub maxyshift: l_int32,
    #[doc = "< one of L_ARABIC_NUMERALS, etc."]
    pub charset_type: l_int32,
    #[doc = "< expected number of classes in charset"]
    pub charset_size: l_int32,
    #[doc = "< min number of samples without padding"]
    pub min_nopad: l_int32,
    #[doc = "< number of training samples"]
    pub num_samples: l_int32,
    #[doc = "< min width averaged unscaled templates"]
    pub minwidth_u: l_int32,
    #[doc = "< max width averaged unscaled templates"]
    pub maxwidth_u: l_int32,
    #[doc = "< min height averaged unscaled templates"]
    pub minheight_u: l_int32,
    #[doc = "< max height averaged unscaled templates"]
    pub maxheight_u: l_int32,
    #[doc = "< min width averaged scaled templates"]
    pub minwidth: l_int32,
    #[doc = "< max width averaged scaled templates"]
    pub maxwidth: l_int32,
    #[doc = "< set to 1 when averaged bitmaps are made"]
    pub ave_done: l_int32,
    #[doc = "< set to 1 when training is complete or  */\n/*!< identification has started"]
    pub train_done: l_int32,
    #[doc = "< max width/height ratio to split"]
    pub max_wh_ratio: l_float32,
    #[doc = "< max of max/min template height ratio"]
    pub max_ht_ratio: l_float32,
    #[doc = "< min component width kept in splitting"]
    pub min_splitw: l_int32,
    #[doc = "< max component height kept in splitting"]
    pub max_splith: l_int32,
    #[doc = "< text array for arbitrary char set"]
    pub sa_text: *mut Sarray,
    #[doc = "< index-to-char lut for arbitrary charset"]
    pub dna_tochar: *mut L_Dna,
    #[doc = "< table for finding centroids"]
    pub centtab: *mut l_int32,
    #[doc = "< table for finding pixel sums"]
    pub sumtab: *mut l_int32,
    #[doc = "< all unscaled templates for each class"]
    pub pixaa_u: *mut Pixaa,
    #[doc = "< centroids of all unscaled templates"]
    pub ptaa_u: *mut Ptaa,
    #[doc = "< area of all unscaled templates"]
    pub naasum_u: *mut Numaa,
    #[doc = "< all (scaled) templates for each class"]
    pub pixaa: *mut Pixaa,
    #[doc = "< centroids of all (scaledl) templates"]
    pub ptaa: *mut Ptaa,
    #[doc = "< area of all (scaled) templates"]
    pub naasum: *mut Numaa,
    #[doc = "< averaged unscaled templates per class"]
    pub pixa_u: *mut Pixa,
    #[doc = "< centroids of unscaled ave. templates"]
    pub pta_u: *mut Pta,
    #[doc = "< area of unscaled averaged templates"]
    pub nasum_u: *mut Numa,
    #[doc = "< averaged (scaled) templates per class"]
    pub pixa: *mut Pixa,
    #[doc = "< centroids of (scaled) ave. templates"]
    pub pta: *mut Pta,
    #[doc = "< area of (scaled) averaged templates"]
    pub nasum: *mut Numa,
    #[doc = "< all input training images"]
    pub pixa_tr: *mut Pixa,
    #[doc = "< unscaled and scaled averaged bitmaps"]
    pub pixadb_ave: *mut Pixa,
    #[doc = "< input images for identifying"]
    pub pixa_id: *mut Pixa,
    #[doc = "< debug: best match of input against ave."]
    pub pixdb_ave: *mut Pix,
    #[doc = "< debug: best matches within range"]
    pub pixdb_range: *mut Pix,
    #[doc = "< debug: bootstrap training results"]
    pub pixadb_boot: *mut Pixa,
    #[doc = "< debug: splitting results"]
    pub pixadb_split: *mut Pixa,
    #[doc = "< bmf fonts"]
    pub bmf: *mut L_Bmf,
    #[doc = "< font size of bmf; default is 6 pt"]
    pub bmf_size: l_int32,
    #[doc = "< temp data used for image decoding"]
    pub did: *mut L_Rdid,
    #[doc = "< temp data used for holding best char"]
    pub rch: *mut L_Rch,
    #[doc = "< temp data used for array of best chars"]
    pub rcha: *mut L_Rcha,
}
#[test]
fn bindgen_test_layout_L_Recog() {
    const UNINIT: ::std::mem::MaybeUninit<L_Recog> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Recog>(),
        320usize,
        concat!("Size of: ", stringify!(L_Recog))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Recog>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Recog))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scalew) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scalew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaleh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scaleh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linew) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(linew)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).templ_use) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(templ_use)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxarraysize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxarraysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setsize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(setsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxyshift) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxyshift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charset_type) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).charset_size) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_nopad) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_nopad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_samples) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(num_samples)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minwidth_u) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxwidth_u) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minheight_u) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minheight_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxheight_u) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxheight_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minwidth) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxwidth) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ave_done) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ave_done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).train_done) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(train_done)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_wh_ratio) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_wh_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_ht_ratio) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_ht_ratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_splitw) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_splitw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_splith) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_splith)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_text) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sa_text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dna_tochar) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(dna_tochar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).centtab) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(centtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sumtab) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sumtab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixaa_u) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptaa_u) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naasum_u) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixaa) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptaa) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naasum) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixa_u) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pta_u) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasum_u) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixa) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pta) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasum) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixa_tr) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_tr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixadb_ave) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_ave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixa_id) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixdb_ave) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_ave)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixdb_range) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixadb_boot) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_boot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixadb_split) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_split)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bmf) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bmf_size) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).did) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rch) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rcha) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rcha)
        )
    );
}
pub type L_RECOG = L_Recog;
#[doc = "  Data returned from correlation matching on a single character"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rch {
    #[doc = "< index of best template"]
    pub index: l_int32,
    #[doc = "< correlation score of best template"]
    pub score: l_float32,
    #[doc = "< character string of best template"]
    pub text: *mut ::std::os::raw::c_char,
    #[doc = "< index of best sample (within the best    */\n/*!< template class, if all samples are used)"]
    pub sample: l_int32,
    #[doc = "< x-location of template (delx + shiftx)"]
    pub xloc: l_int32,
    #[doc = "< y-location of template (dely + shifty)"]
    pub yloc: l_int32,
    #[doc = "< width of best template"]
    pub width: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rch() {
    const UNINIT: ::std::mem::MaybeUninit<L_Rch> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Rch>(),
        32usize,
        concat!("Size of: ", stringify!(L_Rch))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rch>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rch))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).score) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sample) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xloc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(xloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yloc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(yloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(width)
        )
    );
}
#[doc = "  Data returned from correlation matching on a single character"]
pub type L_RCH = L_Rch;
#[doc = "  Data returned from correlation matching on an array of characters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rcha {
    #[doc = "< indices of best templates"]
    pub naindex: *mut Numa,
    #[doc = "< correlation scores of best templates"]
    pub nascore: *mut Numa,
    #[doc = "< character strings of best templates"]
    pub satext: *mut Sarray,
    #[doc = "< indices of best samples"]
    pub nasample: *mut Numa,
    #[doc = "< x-locations of templates (delx + shiftx)"]
    pub naxloc: *mut Numa,
    #[doc = "< y-locations of templates (dely + shifty)"]
    pub nayloc: *mut Numa,
    #[doc = "< widths of best templates"]
    pub nawidth: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rcha() {
    const UNINIT: ::std::mem::MaybeUninit<L_Rcha> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Rcha>(),
        56usize,
        concat!("Size of: ", stringify!(L_Rcha))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rcha>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rcha))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naindex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naindex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nascore) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).satext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(satext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasample) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nasample)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naxloc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nayloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nayloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nawidth) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nawidth)
        )
    );
}
#[doc = "  Data returned from correlation matching on an array of characters"]
pub type L_RCHA = L_Rcha;
#[doc = "  Data used for decoding a line of characters."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rdid {
    #[doc = "< clone of pix to be decoded"]
    pub pixs: *mut Pix,
    #[doc = "< count array for each averaged template"]
    pub counta: *mut *mut l_int32,
    #[doc = "< best y-shift array per average template"]
    pub delya: *mut *mut l_int32,
    #[doc = "< number of averaged templates"]
    pub narray: l_int32,
    #[doc = "< size of count array (width of pixs)"]
    pub size: l_int32,
    #[doc = "< setwidths for each template"]
    pub setwidth: *mut l_int32,
    #[doc = "< pixel count in pixs by column"]
    pub nasum: *mut Numa,
    #[doc = "< first moment of pixels in pixs by cols"]
    pub namoment: *mut Numa,
    #[doc = "< 1 if full arrays are made; 0 otherwise"]
    pub fullarrays: l_int32,
    #[doc = "< channel coeffs for template fg term"]
    pub beta: *mut l_float32,
    #[doc = "< channel coeffs for bit-and term"]
    pub gamma: *mut l_float32,
    #[doc = "< score on trellis"]
    pub trellisscore: *mut l_float32,
    #[doc = "< template on trellis (for backtrack)"]
    pub trellistempl: *mut l_int32,
    #[doc = "< indices of best path templates"]
    pub natempl: *mut Numa,
    #[doc = "< x locations of best path templates"]
    pub naxloc: *mut Numa,
    #[doc = "< y locations of best path templates"]
    pub nadely: *mut Numa,
    #[doc = "< widths of best path templates"]
    pub nawidth: *mut Numa,
    #[doc = "< Viterbi result for splitting input pixs"]
    pub boxa: *mut Boxa,
    #[doc = "< correlation scores: best path templates"]
    pub nascore: *mut Numa,
    #[doc = "< indices of best rescored templates"]
    pub natempl_r: *mut Numa,
    #[doc = "< samples of best scored templates"]
    pub nasample_r: *mut Numa,
    #[doc = "< x locations of best rescoredtemplates"]
    pub naxloc_r: *mut Numa,
    #[doc = "< y locations of best rescoredtemplates"]
    pub nadely_r: *mut Numa,
    #[doc = "< widths of best rescoredtemplates"]
    pub nawidth_r: *mut Numa,
    #[doc = "< correlation scores: rescored templates"]
    pub nascore_r: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rdid() {
    const UNINIT: ::std::mem::MaybeUninit<L_Rdid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Rdid>(),
        192usize,
        concat!("Size of: ", stringify!(L_Rdid))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rdid>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rdid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(counta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delya) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(delya)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).narray) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(narray)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setwidth) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(setwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasum) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namoment) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(namoment)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fullarrays) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(fullarrays)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trellisscore) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellisscore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trellistempl) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellistempl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).natempl) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naxloc) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nadely) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nawidth) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boxa) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nascore) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).natempl_r) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasample_r) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasample_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).naxloc_r) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nadely_r) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nawidth_r) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth_r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nascore_r) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore_r)
        )
    );
}
#[doc = "  Data used for decoding a line of characters."]
pub type L_RDID = L_Rdid;
#[doc = "< character set type is not specified"]
pub const L_UNKNOWN: _bindgen_ty_92 = 0;
#[doc = "< 10 digits"]
pub const L_ARABIC_NUMERALS: _bindgen_ty_92 = 1;
#[doc = "< 7 lower-case letters (i,v,x,l,c,d,m)"]
pub const L_LC_ROMAN_NUMERALS: _bindgen_ty_92 = 2;
#[doc = "< 7 upper-case letters (I,V,X,L,C,D,M)"]
pub const L_UC_ROMAN_NUMERALS: _bindgen_ty_92 = 3;
#[doc = "< 26 lower-case letters"]
pub const L_LC_ALPHA: _bindgen_ty_92 = 4;
#[doc = "< 26 upper-case letters"]
pub const L_UC_ALPHA: _bindgen_ty_92 = 5;
#[doc = " Character Set"]
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
#[doc = "< use all templates; default"]
pub const L_USE_ALL_TEMPLATES: _bindgen_ty_93 = 0;
#[doc = "< use average templates; special cases"]
pub const L_USE_AVERAGE_TEMPLATES: _bindgen_ty_93 = 1;
#[doc = " Template Select"]
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
#[doc = " Regression test parameter packer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_RegParams {
    #[doc = "< stream to temporary output file for compare mode"]
    pub fp: *mut FILE,
    #[doc = "< name of test, without '_reg'"]
    pub testname: *mut ::std::os::raw::c_char,
    #[doc = "< name of temp file for compare mode output"]
    pub tempfile: *mut ::std::os::raw::c_char,
    #[doc = "< generate, compare or display"]
    pub mode: l_int32,
    #[doc = "< index into saved files for this test; 0-based"]
    pub index: l_int32,
    #[doc = "< overall result of the test"]
    pub success: l_int32,
    #[doc = "< 1 if in display mode; 0 otherwise"]
    pub display: l_int32,
    #[doc = "< marks beginning of the reg test"]
    pub tstart: L_TIMER,
}
#[test]
fn bindgen_test_layout_L_RegParams() {
    const UNINIT: ::std::mem::MaybeUninit<L_RegParams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_RegParams>(),
        48usize,
        concat!("Size of: ", stringify!(L_RegParams))
    );
    assert_eq!(
        ::std::mem::align_of::<L_RegParams>(),
        8usize,
        concat!("Alignment of ", stringify!(L_RegParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).testname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(testname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tempfile) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tempfile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).success) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tstart) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tstart)
        )
    );
}
#[doc = " Regression test parameter packer"]
pub type L_REGPARAMS = L_RegParams;
pub const L_REG_GENERATE: _bindgen_ty_94 = 0;
pub const L_REG_COMPARE: _bindgen_ty_94 = 1;
pub const L_REG_DISPLAY: _bindgen_ty_94 = 2;
#[doc = " Running modes for the test */\n/*! Regtest Mode"]
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
#[doc = " \\file stringcode.h\n\n     Data structure to hold accumulating generated code for storing\n     and extracting serializable leptonica objects (e.g., pixa, recog).\n\n     Also a flag for selecting a string from the L_GenAssoc struct\n     in stringcode."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_StrCode {
    #[doc = "< index for function and output file names"]
    pub fileno: l_int32,
    #[doc = "< index into struct currently being stored"]
    pub ifunc: l_int32,
    #[doc = "< store case code for extraction"]
    pub function: *mut SARRAY,
    #[doc = "< store base64 encoded data as strings"]
    pub data: *mut SARRAY,
    #[doc = "< store line in description table"]
    pub descr: *mut SARRAY,
    #[doc = "< number of data strings"]
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_L_StrCode() {
    const UNINIT: ::std::mem::MaybeUninit<L_StrCode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_StrCode>(),
        40usize,
        concat!("Size of: ", stringify!(L_StrCode))
    );
    assert_eq!(
        ::std::mem::align_of::<L_StrCode>(),
        8usize,
        concat!("Alignment of ", stringify!(L_StrCode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fileno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifunc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(ifunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " \\file stringcode.h\n\n     Data structure to hold accumulating generated code for storing\n     and extracting serializable leptonica objects (e.g., pixa, recog).\n\n     Also a flag for selecting a string from the L_GenAssoc struct\n     in stringcode."]
pub type L_STRCODE = L_StrCode;
#[doc = "< typedef for the data type"]
pub const L_STR_TYPE: _bindgen_ty_95 = 0;
#[doc = "< name of the data type"]
pub const L_STR_NAME: _bindgen_ty_95 = 1;
#[doc = "< reader to get the data type from file"]
pub const L_STR_READER: _bindgen_ty_95 = 2;
#[doc = "< reader to get the compressed string in memory"]
pub const L_STR_MEMREADER: _bindgen_ty_95 = 3;
#[doc = " Select string in stringcode for a specific serializable data type */\n/*! Stringcode Select"]
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
#[doc = " \\file sudoku.h\n\n <pre>\n    The L_Sudoku holds all the information of the current state.\n\n    The input to sudokuCreate() is a file with any number of lines\n    starting with '#', followed by 9 lines consisting of 9 numbers\n    in each line.  These have the known values and use 0 for the unknowns.\n    Blank lines are ignored.\n\n    The %locs array holds the indices of the unknowns, numbered\n    left-to-right and top-to-bottom from 0 to 80.  The array size\n    is initialized to %num.  %current is the index into the %locs\n    array of the current guess: locs[current].\n\n    The %state array is used to determine the validity of each guess.\n    It is of size 81, and is initialized by setting the unknowns to 0\n    and the knowns to their input values.\n </pre>"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Sudoku {
    #[doc = "< number of unknowns"]
    pub num: l_int32,
    #[doc = "< location of unknowns"]
    pub locs: *mut l_int32,
    #[doc = "< index into %locs of current location"]
    pub current: l_int32,
    #[doc = "< initial state, with 0 representing     */\n/*!< the unknowns"]
    pub init: *mut l_int32,
    #[doc = "< present state, including inits and     */\n/*!< guesses of unknowns up to %current"]
    pub state: *mut l_int32,
    #[doc = "< shows current number of guesses"]
    pub nguess: l_int32,
    #[doc = "< set to 1 when solved"]
    pub finished: l_int32,
    #[doc = "< set to 1 if no solution is possible"]
    pub failure: l_int32,
}
#[test]
fn bindgen_test_layout_L_Sudoku() {
    const UNINIT: ::std::mem::MaybeUninit<L_Sudoku> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_Sudoku>(),
        56usize,
        concat!("Size of: ", stringify!(L_Sudoku))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Sudoku>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Sudoku))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(locs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).init) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nguess) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(nguess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).finished) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(finished)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).failure) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(failure)
        )
    );
}
#[doc = " \\file sudoku.h\n\n <pre>\n    The L_Sudoku holds all the information of the current state.\n\n    The input to sudokuCreate() is a file with any number of lines\n    starting with '#', followed by 9 lines consisting of 9 numbers\n    in each line.  These have the known values and use 0 for the unknowns.\n    Blank lines are ignored.\n\n    The %locs array holds the indices of the unknowns, numbered\n    left-to-right and top-to-bottom from 0 to 80.  The array size\n    is initialized to %num.  %current is the index into the %locs\n    array of the current guess: locs[current].\n\n    The %state array is used to determine the validity of each guess.\n    It is of size 81, and is initialized by setting the unknowns to 0\n    and the knowns to their input values.\n </pre>"]
pub type L_SUDOKU = L_Sudoku;
pub const L_SUDOKU_INIT: _bindgen_ty_96 = 0;
pub const L_SUDOKU_STATE: _bindgen_ty_96 = 1;
#[doc = " For printing out array data */\n/*! Sudoku Output"]
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
#[doc = " Simple data structure to hold watershed data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WShed {
    #[doc = "< clone of input 8 bpp pixs"]
    pub pixs: *mut Pix,
    #[doc = "< clone of input 1 bpp seed (marker) pixm"]
    pub pixm: *mut Pix,
    #[doc = "< minimum depth allowed for a watershed"]
    pub mindepth: l_int32,
    #[doc = "< 16 bpp label pix"]
    pub pixlab: *mut Pix,
    #[doc = "< scratch pix for computing wshed regions"]
    pub pixt: *mut Pix,
    #[doc = "< line ptrs for pixs"]
    pub lines8: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixm"]
    pub linem1: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixlab"]
    pub linelab32: *mut *mut ::std::os::raw::c_void,
    #[doc = "< line ptrs for pixt"]
    pub linet1: *mut *mut ::std::os::raw::c_void,
    #[doc = "< result: 1 bpp pixa of watersheds"]
    pub pixad: *mut Pixa,
    #[doc = "< pta of initial seed pixels"]
    pub ptas: *mut Pta,
    #[doc = "< numa of seed indicators; 0 if completed"]
    pub nasi: *mut Numa,
    #[doc = "< numa of initial seed heights"]
    pub nash: *mut Numa,
    #[doc = "< numa of initial minima heights"]
    pub namh: *mut Numa,
    #[doc = "< result: numa of watershed levels"]
    pub nalevels: *mut Numa,
    #[doc = "< number of seeds (markers)"]
    pub nseeds: l_int32,
    #[doc = "< number of minima different from seeds"]
    pub nother: l_int32,
    #[doc = "< lut for pixel indices"]
    pub lut: *mut l_int32,
    #[doc = "< back-links into lut, for updates"]
    pub links: *mut *mut Numa,
    #[doc = "< size of links array"]
    pub arraysize: l_int32,
    #[doc = "< set to 1 for debug output"]
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_WShed() {
    const UNINIT: ::std::mem::MaybeUninit<L_WShed> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<L_WShed>(),
        152usize,
        concat!("Size of: ", stringify!(L_WShed))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WShed>(),
        8usize,
        concat!("Alignment of ", stringify!(L_WShed))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mindepth) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(mindepth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixlab) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixlab)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lines8) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lines8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linem1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linem1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linelab32) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linelab32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).linet1) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linet1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pixad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptas) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(ptas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nasi) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nasi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nash) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).namh) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(namh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nalevels) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nalevels)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nseeds) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nseeds)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nother) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nother)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lut) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).links) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arraysize) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(arraysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).debug) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(debug)
        )
    );
}
#[doc = " Simple data structure to hold watershed data."]
pub type L_WSHED = L_WShed;
extern "C" {
    pub fn pixCleanBackgroundToWhite(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormSimple(pixs: *mut PIX, pixim: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormGrayArray(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArrays(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormGrayArrayMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArraysMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixm: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFillMapHoles(pix: *mut PIX, nx: l_int32, ny: l_int32, filltype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixExtendByReplication(pixs: *mut PIX, addw: l_int32, addh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSmoothConnectedRegions(pixs: *mut PIX, pixm: *mut PIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetInvBackgroundMap(
        pixs: *mut PIX,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundGrayMap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundRGBMap(
        pixs: *mut PIX,
        pixmr: *mut PIX,
        pixmg: *mut PIX,
        pixmb: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyVariableGrayMap(pixs: *mut PIX, pixg: *mut PIX, target: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        mapval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormNoSatRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        factor: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdSpreadNorm(
        pixs: *mut PIX,
        filtertype: l_int32,
        edgethresh: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
        targetthresh: l_int32,
        ppixth: *mut *mut PIX,
        ppixb: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormFlex(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastNorm(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffine(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getAffineXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineInvertXform(vc: *mut l_float32, pvci: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn affineXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelColor(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        colorval: l_uint32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelGray(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        grayval: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn gaussjordan(a: *mut *mut l_float32, b: *mut l_float32, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAffineSequential(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        bw: l_int32,
        bh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn createMatrix2dTranslate(transx: l_float32, transy: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dScale(scalex: l_float32, scaley: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dRotate(xc: l_float32, yc: l_float32, angle: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn ptaTranslate(ptas: *mut PTA, transx: l_float32, transy: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaScale(ptas: *mut PTA, scalex: l_float32, scaley: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaRotate(ptas: *mut PTA, xc: l_float32, yc: l_float32, angle: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaTranslate(boxas: *mut BOXA, transx: l_float32, transy: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaScale(boxas: *mut BOXA, scalex: l_float32, scaley: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaRotate(
        boxas: *mut BOXA,
        xc: l_float32,
        yc: l_float32,
        angle: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn ptaAffineTransform(ptas: *mut PTA, mat: *mut l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaAffineTransform(boxas: *mut BOXA, mat: *mut l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn l_productMatVec(
        mat: *mut l_float32,
        vecs: *mut l_float32,
        vecd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat2(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat3(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat4(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        mat4: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_getDataBit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_clearDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_setDataBitVal(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataDibit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataQbit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataByte(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataByte(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataTwoBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataFourBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn barcodeDispatchDecoder(
        barstr: *mut ::std::os::raw::c_char,
        format: l_int32,
        debugflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn barcodeFormatIsSupported(format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFindBaselines(pixs: *mut PIX, ppta: *mut *mut PTA, pixadb: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixDeskewLocal(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetLocalSkewTransform(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pptas: *mut *mut PTA,
        pptad: *mut *mut PTA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLocalSkewAngles(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pa: *mut l_float32,
        pb: *mut l_float32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bbufferCreate(indata: *const l_uint8, nalloc: l_int32) -> *mut L_BBUFFER;
}
extern "C" {
    pub fn bbufferDestroy(pbb: *mut *mut L_BBUFFER);
}
extern "C" {
    pub fn bbufferDestroyAndSaveData(pbb: *mut *mut L_BBUFFER, pnbytes: *mut usize)
        -> *mut l_uint8;
}
extern "C" {
    pub fn bbufferRead(bb: *mut L_BBUFFER, src: *mut l_uint8, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferReadStream(bb: *mut L_BBUFFER, fp: *mut FILE, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferExtendArray(bb: *mut L_BBUFFER, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferWrite(
        bb: *mut L_BBUFFER,
        dest: *mut l_uint8,
        nbytes: usize,
        pnout: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn bbufferWriteStream(
        bb: *mut L_BBUFFER,
        fp: *mut FILE,
        nbytes: usize,
        pnout: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBilateral(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGray(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGrayExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockBilateralExact(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRangeKernel(range_stdev: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn pixBilinearSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinear(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getBilinearXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn bilinearXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bilinearXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuAdaptiveThreshold(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskedThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSauvolaBinarizeTiled(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        nx: l_int32,
        ny: l_int32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaBinarize(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        addborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixsd: *mut *mut PIX,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaOnContrastNorm(
        pixs: *mut PIX,
        mindiff: l_int32,
        ppixn: *mut *mut PIX,
        ppixth: *mut *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThreshOnDoubleNorm(pixs: *mut PIX, mindiff: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdByConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        start: l_int32,
        end: l_int32,
        incr: l_int32,
        thresh48: l_float32,
        threshdiff: l_float32,
        pglobthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixThresholdByHisto(
        pixs: *mut PIX,
        factor: l_int32,
        halfw: l_int32,
        delta: l_float32,
        pthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        ppixhisto: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExpandBinaryReplicate(pixs: *mut PIX, xfact: l_int32, yfact: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandBinaryPower2(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceBinary2(pixs: *mut PIX, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinaryCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinary2(pixs: *mut PIX, level: l_int32, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn makeSubsampleTab2x() -> *mut l_uint8;
}
extern "C" {
    pub fn pixBlend(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendMask(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGray(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayInverse(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColor(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColorByChannel(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayAdapt(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        shift: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFadeWithGray(
        pixs: *mut PIX,
        pixb: *mut PIX,
        factor: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendHardLight(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendCmap(
        pixs: *mut PIX,
        pixb: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlendWithGrayMask(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        pixg: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBackgroundToColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyByColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAlphaBlendUniform(pixs: *mut PIX, color: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaToBlend(pixs: *mut PIX, fract: l_float32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetAlphaOverWhite(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearEdgeFade(
        pixs: *mut PIX,
        dir: l_int32,
        fadeto: l_int32,
        distfract: l_float32,
        maxfade: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfCreate(dir: *const ::std::os::raw::c_char, fontsize: l_int32) -> *mut L_BMF;
}
extern "C" {
    pub fn bmfDestroy(pbmf: *mut *mut L_BMF);
}
extern "C" {
    pub fn bmfGetPix(bmf: *mut L_BMF, chr: ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn bmfGetWidth(bmf: *mut L_BMF, chr: ::std::os::raw::c_char, pw: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn bmfGetBaseline(
        bmf: *mut L_BMF,
        chr: ::std::os::raw::c_char,
        pbaseline: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetFont(
        dir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
        pbl0: *mut l_int32,
        pbl1: *mut l_int32,
        pbl2: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSaveFont(
        indir: *const ::std::os::raw::c_char,
        outdir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamBmp(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemBmp(cdata: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamBmp(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemBmp(pfdata: *mut *mut l_uint8, pfsize: *mut usize, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn l_bootnum_gen1() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen2() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen3() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen4(nsamp: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn boxCreate(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCreateValid(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCopy(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxClone(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxDestroy(pbox: *mut *mut BOX);
}
extern "C" {
    pub fn boxGetGeometry(
        box_: *mut BOX,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetGeometry(box_: *mut BOX, x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxGetSideLocations(
        box_: *mut BOX,
        pl: *mut l_int32,
        pr: *mut l_int32,
        pt: *mut l_int32,
        pb: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetSideLocations(
        box_: *mut BOX,
        l: l_int32,
        r: l_int32,
        t: l_int32,
        b: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxIsValid(box_: *mut BOX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaCreate(n: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCopy(boxa: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaDestroy(pboxa: *mut *mut BOXA);
}
extern "C" {
    pub fn boxaAddBox(boxa: *mut BOXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArray(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArrayToSize(boxa: *mut BOXA, size: usize) -> l_ok;
}
extern "C" {
    pub fn boxaGetCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetValidCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetValidBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindInvalidBoxes(boxa: *mut BOXA) -> *mut NUMA;
}
extern "C" {
    pub fn boxaGetBoxGeometry(
        boxa: *mut BOXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIsFull(boxa: *mut BOXA, pfull: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaReplaceBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaInsertBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBox(boxa: *mut BOXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBoxAndSave(boxa: *mut BOXA, index: l_int32, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaSaveValid(boxas: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaInitFull(boxa: *mut BOXA, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaClear(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaCreate(n: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaCopy(baas: *mut BOXAA, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaDestroy(pbaa: *mut *mut BOXAA);
}
extern "C" {
    pub fn boxaaAddBoxa(baa: *mut BOXAA, ba: *mut BOXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArray(baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArrayToSize(baa: *mut BOXAA, size: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxa(baa: *mut BOXAA, index: l_int32, accessflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaGetBox(
        baa: *mut BOXAA,
        iboxa: l_int32,
        ibox: l_int32,
        accessflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaaInitFull(baa: *mut BOXAA, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendWithInit(baa: *mut BOXAA, maxindex: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaReplaceBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaInsertBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaRemoveBoxa(baa: *mut BOXAA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaAddBox(
        baa: *mut BOXAA,
        index: l_int32,
        box_: *mut BOX,
        accessflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadStream(fp: *mut FILE) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadMem(data: *const l_uint8, size: usize) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaWrite(filename: *const ::std::os::raw::c_char, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteStream(fp: *mut FILE, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadStream(fp: *mut FILE) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadMem(data: *const l_uint8, size: usize) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWriteDebug(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWrite(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStream(fp: *mut FILE, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStderr(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxPrintStreamInfo(fp: *mut FILE, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxContains(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIntersects(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaContainedInBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBoxa(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        pcontained: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIntersectsBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaIntersectsBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaClipToBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlaps(boxas: *mut BOXA, pixadb: *mut PIXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlapsInPair(
        boxas1: *mut BOXA,
        boxas2: *mut BOXA,
        pboxad1: *mut *mut BOXA,
        pboxad2: *mut *mut BOXA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxOverlapRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxBoundingRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxOverlapFraction(box1: *mut BOX, box2: *mut BOX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxOverlapArea(box1: *mut BOX, box2: *mut BOX, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaHandleOverlaps(
        boxas: *mut BOXA,
        op: l_int32,
        range: l_int32,
        min_overlap: l_float32,
        max_ratio: l_float32,
        pnamap: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxOverlapDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_ovl: *mut l_int32,
        pv_ovl: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSeparationDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_sep: *mut l_int32,
        pv_sep: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxCompareSize(
        box1: *mut BOX,
        box2: *mut BOX,
        type_: l_int32,
        prel: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxContainsPt(
        box_: *mut BOX,
        x: l_float32,
        y: l_float32,
        pcontains: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestToPt(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetNearestToLine(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindNearestBoxes(
        boxa: *mut BOXA,
        dist_select: l_int32,
        range: l_int32,
        pnaaindex: *mut *mut NUMAA,
        pnaadist: *mut *mut NUMAA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestByDirection(
        boxa: *mut BOXA,
        i: l_int32,
        dir: l_int32,
        dist_select: l_int32,
        range: l_int32,
        pindex: *mut l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetCenter(box_: *mut BOX, pcx: *mut l_float32, pcy: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxIntersectByLine(
        box_: *mut BOX,
        x: l_int32,
        y: l_int32,
        slope: l_float32,
        px1: *mut l_int32,
        py1: *mut l_int32,
        px2: *mut l_int32,
        py2: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxClipToRectangle(box_: *mut BOX, wi: l_int32, hi: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxClipToRectangleParams(
        box_: *mut BOX,
        w: l_int32,
        h: l_int32,
        pxstart: *mut l_int32,
        pystart: *mut l_int32,
        pxend: *mut l_int32,
        pyend: *mut l_int32,
        pbw: *mut l_int32,
        pbh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxRelocateOneSide(
        boxd: *mut BOX,
        boxs: *mut BOX,
        loc: l_int32,
        sideflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaAdjustSides(
        boxas: *mut BOXA,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustBoxSides(
        boxa: *mut BOXA,
        index: l_int32,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxAdjustSides(
        boxd: *mut BOX,
        boxs: *mut BOX,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSetSide(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        side: l_int32,
        val: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxSetSide(boxs: *mut BOX, side: l_int32, val: l_int32, thresh: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaAdjustWidthToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustHeightToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxEqual(box1: *mut BOX, box2: *mut BOX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaEqual(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSimilar(
        box1: *mut BOX,
        box2: *mut BOX,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        psimilar: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSimilar(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        debug: l_int32,
        psimilar: *mut l_int32,
        pnasim: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaJoin(boxad: *mut BOXA, boxas: *mut BOXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaJoin(baad: *mut BOXAA, baas: *mut BOXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaSplitEvenOdd(
        boxa: *mut BOXA,
        fillflag: l_int32,
        pboxae: *mut *mut BOXA,
        pboxao: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMergeEvenOdd(boxae: *mut BOXA, boxao: *mut BOXA, fillflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaTransform(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransform(
        box_: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaTransformOrdered(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransformOrdered(
        boxs: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaRotateOrth(boxas: *mut BOXA, w: l_int32, h: l_int32, rotation: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxRotateOrth(box_: *mut BOX, w: l_int32, h: l_int32, rotation: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaShiftWithPta(boxas: *mut BOXA, pta: *mut PTA, dir: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaBinSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSortByIndex(boxas: *mut BOXA, naindex: *mut NUMA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort2d(
        boxas: *mut BOXA,
        pnaad: *mut *mut NUMAA,
        delta1: l_int32,
        delta2: l_int32,
        minh1: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSort2dByIndex(boxas: *mut BOXA, naa: *mut NUMAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaExtractAsNuma(
        boxa: *mut BOXA,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractAsPta(
        boxa: *mut BOXA,
        pptal: *mut *mut PTA,
        pptat: *mut *mut PTA,
        pptar: *mut *mut PTA,
        pptab: *mut *mut PTA,
        pptaw: *mut *mut PTA,
        pptah: *mut *mut PTA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractCorners(boxa: *mut BOXA, loc: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn boxaGetRankVals(
        boxa: *mut BOXA,
        fract: l_float32,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetMedianVals(
        boxa: *mut BOXA,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetAverageSize(boxa: *mut BOXA, pw: *mut l_float32, ph: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetExtent(
        baa: *mut BOXAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaFlattenToBoxa(
        baa: *mut BOXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaFlattenAligned(
        baa: *mut BOXAA,
        num: l_int32,
        fillerbox: *mut BOX,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaEncapsulateAligned(boxa: *mut BOXA, num: l_int32, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaTranspose(baas: *mut BOXAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaAlignBox(
        baa: *mut BOXAA,
        box_: *mut BOX,
        delta: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMaskConnComp(
        pixs: *mut PIX,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskBoxa(pixd: *mut PIX, pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxa(pixs: *mut PIX, boxa: *mut BOXA, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetBlackOrWhiteBoxa(pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxa(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn boxaaDisplay(
        pixs: *mut PIX,
        baa: *mut BOXAA,
        linewba: l_int32,
        linewb: l_int32,
        colorba: l_uint32,
        colorb: l_uint32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayBoxaa(
        pixas: *mut PIXA,
        baa: *mut BOXAA,
        colorflag: l_int32,
        width: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSplitIntoBoxa(
        pixs: *mut PIX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixSplitComponentIntoBoxa(
        pix: *mut PIX,
        box_: *mut BOX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn makeMosaicStrips(w: l_int32, h: l_int32, direction: l_int32, size: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxaCompareRegions(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        areathresh: l_int32,
        pnsame: *mut l_int32,
        pdiffarea: *mut l_float32,
        pdiffxor: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectLargeULComp(
        pixs: *mut PIX,
        areaslop: l_float32,
        yslop: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectLargeULBox(boxas: *mut BOXA, areaslop: l_float32, yslop: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectRange(
        boxas: *mut BOXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaSelectRange(
        baas: *mut BOXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSelectBySize(
        boxas: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeSizeIndicator(
        boxa: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByArea(
        boxas: *mut BOXA,
        area: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeAreaIndicator(boxa: *mut BOXA, area: l_int32, relation: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByWHRatio(
        boxas: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeWHRatioIndicator(
        boxa: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectWithIndicator(
        boxas: *mut BOXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermutePseudorandom(boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermuteRandom(boxad: *mut BOXA, boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSwapBoxes(boxa: *mut BOXA, i: l_int32, j: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaConvertToPta(boxa: *mut BOXA, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBoxa(pta: *mut PTA, ncorners: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxConvertToPta(box_: *mut BOX, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBox(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetExtent(
        boxa: *mut BOXA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetCoverage(
        boxa: *mut BOXA,
        wc: l_int32,
        hc: l_int32,
        exactflag: l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaSizeRange(
        baa: *mut BOXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSizeRange(
        boxa: *mut BOXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaLocationRange(
        boxa: *mut BOXA,
        pminx: *mut l_int32,
        pminy: *mut l_int32,
        pmaxx: *mut l_int32,
        pmaxy: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetSizes(boxa: *mut BOXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn boxaGetArea(boxa: *mut BOXA, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaDisplayTiled(
        boxas: *mut BOXA,
        pixa: *mut PIXA,
        first: l_int32,
        last: l_int32,
        maxwidth: l_int32,
        linewidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn boxaSmoothSequenceMedian(
        boxas: *mut BOXA,
        halfwin: l_int32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWindowedMedian(boxas: *mut BOXA, halfwin: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaModifyWithBoxa(
        boxas: *mut BOXA,
        boxam: *mut BOXA,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcilePairWidth(
        boxas: *mut BOXA,
        delw: l_int32,
        op: l_int32,
        factor: l_float32,
        na: *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeConsistency(
        boxas: *mut BOXA,
        type_: l_int32,
        threshp: l_float32,
        threshm: l_float32,
        pfvarp: *mut l_float32,
        pfvarm: *mut l_float32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaReconcileAllByMedian(
        boxas: *mut BOXA,
        select1: l_int32,
        select2: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSidesByMedian(
        boxas: *mut BOXA,
        select: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSizeByMedian(
        boxas: *mut BOXA,
        type_: l_int32,
        dfract: l_float32,
        sfract: l_float32,
        factor: l_float32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
        pratiowh: *mut l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPlotSides(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaPlotSizes(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaFillSequence(boxas: *mut BOXA, useflag: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeVariation(
        boxa: *mut BOXA,
        type_: l_int32,
        pdel_evenodd: *mut l_float32,
        prms_even: *mut l_float32,
        prms_odd: *mut l_float32,
        prms_all: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMedianDimensions(
        boxas: *mut BOXA,
        pmedw: *mut l_int32,
        pmedh: *mut l_int32,
        pmedwe: *mut l_int32,
        pmedwo: *mut l_int32,
        pmedhe: *mut l_int32,
        pmedho: *mut l_int32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaCreate(nbytes: usize) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromMem(data: *const l_uint8, size: usize) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromFile(fname: *const ::std::os::raw::c_char) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromStream(fp: *mut FILE) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaCopy(bas: *mut L_BYTEA, copyflag: l_int32) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaDestroy(pba: *mut *mut L_BYTEA);
}
extern "C" {
    pub fn l_byteaGetSize(ba: *mut L_BYTEA) -> usize;
}
extern "C" {
    pub fn l_byteaGetData(ba: *mut L_BYTEA, psize: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaCopyData(ba: *mut L_BYTEA, psize: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaAppendData(ba: *mut L_BYTEA, newdata: *const l_uint8, newbytes: usize) -> l_ok;
}
extern "C" {
    pub fn l_byteaAppendString(ba: *mut L_BYTEA, str_: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn l_byteaJoin(ba1: *mut L_BYTEA, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaSplit(ba1: *mut L_BYTEA, splitloc: usize, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaFindEachSequence(
        ba: *mut L_BYTEA,
        sequence: *const l_uint8,
        seqlen: usize,
        pda: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWrite(
        fname: *const ::std::os::raw::c_char,
        ba: *mut L_BYTEA,
        startloc: usize,
        nbytes: usize,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWriteStream(
        fp: *mut FILE,
        ba: *mut L_BYTEA,
        startloc: usize,
        nbytes: usize,
    ) -> l_ok;
}
extern "C" {
    pub fn ccbaDestroy(pccba: *mut *mut CCBORDA);
}
extern "C" {
    pub fn pixGetAllCCBorders(pixs: *mut PIX) -> *mut CCBORDA;
}
extern "C" {
    pub fn pixGetOuterBordersPtaa(pixs: *mut PIX) -> *mut PTAA;
}
extern "C" {
    pub fn pixGetOuterBorder(ccb: *mut CCBORD, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateGlobalLocs(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateStepChains(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaStepChainsToPixCoords(ccba: *mut CCBORDA, coordtype: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSPGlobalLocs(ccba: *mut CCBORDA, ptsflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSinglePath(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaDisplayBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplaySPBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage1(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage2(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaWrite(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteStream(fp: *mut FILE, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaRead(filename: *const ::std::os::raw::c_char) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaReadStream(fp: *mut FILE) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaWriteSVG(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteSVGString(ccba: *mut CCBORDA) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixaThinConnected(
        pixas: *mut PIXA,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixThinConnected(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThinConnectedBySet(
        pixs: *mut PIX,
        type_: l_int32,
        sela: *mut SELA,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaMakeThinSets(index: l_int32, debug: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn pixFindCheckerboardCorners(
        pixs: *mut PIX,
        size: l_int32,
        dilation: l_int32,
        nsels: l_int32,
        ppix_corners: *mut *mut PIX,
        ppta_corners: *mut *mut PTA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbCorrelation(
        dirin: *const ::std::os::raw::c_char,
        thresh: l_float32,
        weight: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbRankHaus(
        dirin: *const ::std::os::raw::c_char,
        size: l_int32,
        rank: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbWordsInTextlines(
        dirin: *const ::std::os::raw::c_char,
        reduction: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weight: l_float32,
        pnatl: *mut *mut NUMA,
        firstpage: l_int32,
        npages: l_int32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn pixGetWordsInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetWordBoxesInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindWordAndCharacterBoxes(
        pixs: *mut PIX,
        boxs: *mut BOX,
        thresh: l_int32,
        pboxaw: *mut *mut BOXA,
        pboxaac: *mut *mut BOXAA,
        debugdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractSortedPattern(boxa: *mut BOXA, na: *mut NUMA) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCompareImagesByBoxes(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        nperline: l_int32,
        nreq: l_int32,
        maxshiftx: l_int32,
        maxshifty: l_int32,
        delx: l_int32,
        dely: l_int32,
        psame: *mut l_int32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorContent(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        mingray: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorMagnitude(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorFraction(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        factor: l_int32,
        ppixfract: *mut l_float32,
        pcolorfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorShiftWhitePoint(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorPixels(
        pixs: *mut PIX,
        threshdiff: l_int32,
        mindist: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverGrayPixels(pixs: *mut PIX, maxlimit: l_int32, satlimit: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorRange(
        pixs: *mut PIX,
        rmin: l_int32,
        rmax: l_int32,
        gmin: l_int32,
        gmax: l_int32,
        bmin: l_int32,
        bmax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindColorRegions(
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_int32,
        lightthresh: l_int32,
        darkthresh: l_int32,
        mindiff: l_int32,
        colordiff: l_int32,
        edgefract: l_float32,
        pcolorfract: *mut l_float32,
        pcolormask1: *mut *mut PIX,
        pcolormask2: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumSignificantGrayColors(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        minfract: l_float32,
        factor: l_int32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorsForQuantization(
        pixs: *mut PIX,
        thresh: l_int32,
        pncolors: *mut l_int32,
        piscolor: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToCmapLossless(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetMostPopulatedColors(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
        parray: *mut *mut l_uint32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSimpleColorQuantize(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBHistogram(pixs: *mut PIX, sigbits: l_int32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn makeRGBIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        sigbits: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn getRGBFromIndex(
        index: l_uint32,
        sigbits: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHasHighlightRed(
        pixs: *mut PIX,
        factor: l_int32,
        minfract: l_float32,
        fthresh: l_float32,
        phasred: *mut l_int32,
        pratio: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_colorfillCreate(pixs: *mut PIX, nx: l_int32, ny: l_int32) -> *mut L_COLORFILL;
}
extern "C" {
    pub fn l_colorfillDestroy(pcf: *mut *mut L_COLORFILL);
}
extern "C" {
    pub fn pixColorContentByLocation(
        cf: *mut L_COLORFILL,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        minmax: l_int32,
        maxdiff: l_int32,
        minarea: l_int32,
        smooth: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorFill(
        pixs: *mut PIX,
        minmax: l_int32,
        maxdiff: l_int32,
        smooth: l_int32,
        minarea: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeColorfillTestData(
        w: l_int32,
        h: l_int32,
        nseeds: l_int32,
        range: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixColorGrayRegions(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorGray(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColorCmap(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearMapToTargetColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelLinearMapToTargetColor(
        scolor: l_uint32,
        srcmap: l_uint32,
        dstmap: l_uint32,
        pdcolor: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixShiftByComponent(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelShiftByComponent(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        srcval: l_uint32,
        dstval: l_uint32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixelFractionalShift(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMapWithInvariantHue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixcmapCreate(depth: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateRandom(
        depth: l_int32,
        hasblack: l_int32,
        haswhite: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateLinear(d: l_int32, nlevels: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCopy(cmaps: *const PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapDestroy(pcmap: *mut *mut PIXCMAP);
}
extern "C" {
    pub fn pixcmapIsValid(cmap: *const PIXCMAP, pix: *mut PIX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddColor(cmap: *mut PIXCMAP, rval: l_int32, gval: l_int32, bval: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapAddRGBA(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNewColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNearestColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapUsableColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pusable: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddBlackOrWhite(cmap: *mut PIXCMAP, color: l_int32, pindex: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapSetBlackAndWhite(
        cmap: *mut PIXCMAP,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetCount(cmap: *const PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetFreeCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDepth(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetMinDepth(cmap: *mut PIXCMAP, pmindepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapClear(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapResetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSetAlpha(cmap: *mut PIXCMAP, index: l_int32, aval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapHasColor(cmap: *mut PIXCMAP, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsOpaque(cmap: *mut PIXCMAP, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapNonOpaqueColorsInfo(
        cmap: *mut PIXCMAP,
        pntrans: *mut l_int32,
        pmax_trans: *mut l_int32,
        pmin_opaque: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsBlackAndWhite(cmap: *mut PIXCMAP, pblackwhite: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapCountGrayColors(cmap: *mut PIXCMAP, pngray: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRankIntensity(
        cmap: *mut PIXCMAP,
        rankval: l_float32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestGrayIndex(
        cmap: *mut PIXCMAP,
        val: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetDistanceToColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRangeValues(
        cmap: *mut PIXCMAP,
        select: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pminindex: *mut l_int32,
        pmaxindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGrayToFalseColor(gamma: l_float32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapGrayToColor(color: l_uint32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapColorToGray(
        cmaps: *mut PIXCMAP,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo4(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo8(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapRead(filename: *const ::std::os::raw::c_char) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadStream(fp: *mut FILE) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadMem(data: *const l_uint8, size: usize) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapWrite(filename: *const ::std::os::raw::c_char, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteStream(fp: *mut FILE, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        cmap: *const PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToArrays(
        cmap: *const PIXCMAP,
        prmap: *mut *mut l_int32,
        pgmap: *mut *mut l_int32,
        pbmap: *mut *mut l_int32,
        pamap: *mut *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToRGBTable(
        cmap: *mut PIXCMAP,
        ptab: *mut *mut l_uint32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSerializeToMemory(
        cmap: *mut PIXCMAP,
        cpc: l_int32,
        pncolors: *mut l_int32,
        pdata: *mut *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapDeserializeFromMemory(
        data: *mut l_uint8,
        cpc: l_int32,
        ncolors: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertToHex(data: *mut l_uint8, ncolors: l_int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixcmapGammaTRC(
        cmap: *mut PIXCMAP,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapContrastTRC(cmap: *mut PIXCMAP, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftIntensity(cmap: *mut PIXCMAP, fraction: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftByComponent(cmap: *mut PIXCMAP, srcval: l_uint32, dstval: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixColorMorph(
        pixs: *mut PIX,
        type_: l_int32,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuant(pixs: *mut PIX, colors: l_int32, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuantGeneral(
        pixs: *mut PIX,
        colors: l_int32,
        ditherflag: l_int32,
        validthresh: l_float32,
        colorthresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRGBToIndexTables(
        cqlevels: l_int32,
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn getOctcubeIndexFromRGB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        rtab: *mut l_uint32,
        gtab: *mut l_uint32,
        btab: *mut l_uint32,
        pindex: *mut l_uint32,
    );
}
extern "C" {
    pub fn pixOctreeQuantByPopulation(
        pixs: *mut PIX,
        level: l_int32,
        ditherflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeQuantNumColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        subsample: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantMixedWithGray(
        pixs: *mut PIX,
        depth: l_int32,
        graylevels: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuant256(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant1(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant2(
        pixs: *mut PIX,
        level: l_int32,
        na: *mut NUMA,
        ncolors: l_int32,
        pnerrors: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuantMixed(
        pixs: *mut PIX,
        level: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        minfract: l_float32,
        maxspan: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuantGenRGB(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeHistogram(pixs: *mut PIX, level: l_int32, pncolors: *mut l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixcmapToOctcubeLUT(cmap: *mut PIXCMAP, level: l_int32, metric: l_int32)
        -> *mut l_int32;
}
extern "C" {
    pub fn pixRemoveUnusedColors(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixNumberOccupiedOctcubes(
        pix: *mut PIX,
        level: l_int32,
        mincount: l_int32,
        minfract: l_float32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMedianCutQuant(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantGeneral(
        pixs: *mut PIX,
        ditherflag: l_int32,
        outdepth: l_int32,
        maxcolors: l_int32,
        sigbits: l_int32,
        maxsub: l_int32,
        checkbw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        maxncolors: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutHisto(pixs: *mut PIX, sigbits: l_int32, subsample: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn pixColorSegment(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        selsize: l_int32,
        finalcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorSegmentCluster(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAssignToNearestColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        level: l_int32,
        countarray: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentClean(pixs: *mut PIX, selsize: l_int32, countarray: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentRemoveColors(
        pixd: *mut PIX,
        pixs: *mut PIX,
        finalcolors: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHSV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertHSVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToHSV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        phval: *mut l_int32,
        psval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertHSVToRGB(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToHSV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertHSVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToSaturation(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToValue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHS(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        satcenter: l_int32,
        sathw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHV(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskSV(
        pixs: *mut PIX,
        satcenter: l_int32,
        sathw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHS(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnasat: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHV(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoSV(
        pixs: *mut PIX,
        factor: l_int32,
        pnasat: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHistoPeaksHSV(
        pixs: *mut PIX,
        type_: l_int32,
        width: l_int32,
        height: l_int32,
        npeaks: l_int32,
        erasefactor: l_float32,
        ppta: *mut *mut PTA,
        pnatot: *mut *mut NUMA,
        ppixa: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn displayHSVColorRange(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        huehw: l_int32,
        sathw: l_int32,
        nsamp: l_int32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToYUV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertYUVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToYUV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pyval: *mut l_int32,
        puval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertYUVToRGB(
        yval: l_int32,
        uval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToYUV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertYUVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToXYZ(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertXYZToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToXYZ(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pfxval: *mut l_float32,
        pfyval: *mut l_float32,
        pfzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertXYZToRGB(
        fxval: l_float32,
        fyval: l_float32,
        fzval: l_float32,
        blackout: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaConvertXYZToLAB(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToXYZ(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn convertXYZToLAB(
        xval: l_float32,
        yval: l_float32,
        zval: l_float32,
        plval: *mut l_float32,
        paval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToXYZ(
        lval: l_float32,
        aval: l_float32,
        bval: l_float32,
        pxval: *mut l_float32,
        pyval: *mut l_float32,
        pzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToLAB(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToLAB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pflval: *mut l_float32,
        pfaval: *mut l_float32,
        pfbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToRGB(
        flval: l_float32,
        faval: l_float32,
        fbval: l_float32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeGamutRGB(scale: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixEqual(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithAlpha(
        pix1: *mut PIX,
        pix2: *mut PIX,
        use_alpha: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithCmap(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn cmapEqual(
        cmap1: *mut PIXCMAP,
        cmap2: *mut PIXCMAP,
        ncomps: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUsesCmapColor(pixs: *mut PIX, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationBinary(pix1: *mut PIX, pix2: *mut PIX, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayDiffBinary(pix1: *mut PIX, pix2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCompareBinary(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        pfract: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayOrRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGray(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareTiled(
        pix1: *mut PIX,
        pix2: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRankDifference(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTestForSimilarity(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        maxfract: l_float32,
        maxave: l_float32,
        psimilar: *mut l_int32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceStats(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        pfractdiff: *mut l_float32,
        pavediff: *mut l_float32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceHistogram(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetPerceptualDiff(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        sampling: l_int32,
        dilation: l_int32,
        mindiff: l_int32,
        pfract: *mut l_float32,
        ppixdiff1: *mut *mut PIX,
        ppixdiff2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPSNR(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        ppsnr: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaComparePhotoRegionsByHisto(
        pixa: *mut PIXA,
        minratio: l_float32,
        textthresh: l_float32,
        factor: l_int32,
        n: l_int32,
        simthresh: l_float32,
        pnai: *mut *mut NUMA,
        pscores: *mut *mut l_float32,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixComparePhotoRegionsByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenPhotoHistos(
        pixs: *mut PIX,
        box_: *mut BOX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        debugindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPadToCenterCentroid(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCentroid8(
        pixs: *mut PIX,
        factor: l_int32,
        pcx: *mut l_float32,
        pcy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfPhotoImage(
        pix: *mut PIX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn compareTilesByHisto(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        minratio: l_float32,
        w1: l_int32,
        h1: l_int32,
        w2: l_int32,
        h2: l_int32,
        pscore: *mut l_float32,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        maxgray: l_int32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropAlignedToCentroid(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        pbox1: *mut *mut BOX,
        pbox2: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_compressGrayHistograms(
        naa: *mut NUMAA,
        w: l_int32,
        h: l_int32,
        psize: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_uncompressGrayHistograms(
        bytea: *mut l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixCompareWithTranslation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        thresh: l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBestCorrelation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        etransx: l_int32,
        etransy: l_int32,
        maxshift: l_int32,
        tab8: *mut l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnComp(pixs: *mut PIX, ppixa: *mut *mut PIXA, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompPixa(
        pixs: *mut PIX,
        ppixa: *mut *mut PIXA,
        connectivity: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompBB(pixs: *mut PIX, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixCountConnComp(pixs: *mut PIX, connectivity: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn nextOnPixelInRaster(
        pixs: *mut PIX,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillBB(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill4BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill8BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill4(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill8(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn convertFilesTo1bpp(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        upscaling: l_int32,
        thresh: l_int32,
        firstpage: l_int32,
        npages: l_int32,
        dirout: *const ::std::os::raw::c_char,
        outformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlockconv(pix: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGray(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvAccum(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayUnnormalized(pixs: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvTiled(
        pix: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayTile(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedStats(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixms: *mut *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWindowedMean(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedMeanSquare(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedVariance(
        pixm: *mut PIX,
        pixms: *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanSquareAccum(pixs: *mut PIX) -> *mut DPIX;
}
extern "C" {
    pub fn pixBlockrank(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlocksum(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCensusTransform(pixs: *mut PIX, halfsize: l_int32, pixacc: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolve(
        pixs: *mut PIX,
        kel: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveSep(
        pixs: *mut PIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGB(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGBSep(pixs: *mut PIX, kelx: *mut L_KERNEL, kely: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvolve(fpixs: *mut FPIX, kel: *mut L_KERNEL, normflag: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixConvolveSep(
        fpixs: *mut FPIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        normflag: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvolveWithBias(
        pixs: *mut PIX,
        kel1: *mut L_KERNEL,
        kel2: *mut L_KERNEL,
        force8: l_int32,
        pbias: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setConvolveSampling(xfact: l_int32, yfact: l_int32);
}
extern "C" {
    pub fn pixAddGaussianNoise(pixs: *mut PIX, stdev: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn gaussDistribSampling() -> l_float32;
}
extern "C" {
    pub fn pixCorrelationScore(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreThresholded(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        downcount: *mut l_int32,
        score_threshold: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreSimple(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreShifted(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_int32,
        dely: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpCreate(pixs: *mut PIX, pageno: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpCreateRef(pageno: l_int32, refpage: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpDestroy(pdew: *mut *mut L_DEWARP);
}
extern "C" {
    pub fn dewarpaCreate(
        nptrs: l_int32,
        sampling: l_int32,
        redfactor: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaCreateFromPixacomp(
        pixac: *mut PIXAC,
        useboth: l_int32,
        sampling: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaDestroy(pdewa: *mut *mut L_DEWARPA);
}
extern "C" {
    pub fn dewarpaDestroyDewarp(dewa: *mut L_DEWARPA, pageno: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertDewarp(dewa: *mut L_DEWARPA, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpaGetDewarp(dewa: *mut L_DEWARPA, index: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpaSetCurvatures(
        dewa: *mut L_DEWARPA,
        max_linecurv: l_int32,
        min_diff_linecurv: l_int32,
        max_diff_linecurv: l_int32,
        max_edgecurv: l_int32,
        max_diff_edgecurv: l_int32,
        max_edgeslope: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaUseBothArrays(dewa: *mut L_DEWARPA, useboth: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetCheckColumns(dewa: *mut L_DEWARPA, check_columns: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetMaxDistance(dewa: *mut L_DEWARPA, maxdist: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadStream(fp: *mut FILE) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadMem(data: *const l_uint8, size: usize) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpWrite(filename: *const ::std::os::raw::c_char, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteStream(fp: *mut FILE, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadStream(fp: *mut FILE) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadMem(data: *const l_uint8, size: usize) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaWrite(filename: *const ::std::os::raw::c_char, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteStream(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        dewa: *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildPageModel(
        dew: *mut L_DEWARP,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpFindVertDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA, rotflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpFindHorizDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn dewarpGetTextlineCenters(pixs: *mut PIX, debugflag: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpRemoveShortLines(
        pixs: *mut PIX,
        ptaas: *mut PTAA,
        fract: l_float32,
        debugflag: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpFindHorizSlopeDisparity(
        dew: *mut L_DEWARP,
        pixb: *mut PIX,
        fractthresh: l_float32,
        parity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildLineModel(
        dew: *mut L_DEWARP,
        opensize: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStatus(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pvsuccess: *mut l_int32,
        phsuccess: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparity(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        grayin: l_int32,
        x: l_int32,
        y: l_int32,
        ppixd: *mut *mut PIX,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparityBoxa(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        mapdir: l_int32,
        x: l_int32,
        y: l_int32,
        pboxad: *mut *mut BOXA,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpMinimize(dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpPopulateFullRes(dew: *mut L_DEWARP, pix: *mut PIX, x: l_int32, y: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePage(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixd: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageInit(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixb: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageRun(
        pixs: *mut PIX,
        pixb: *mut PIX,
        dewa: *mut L_DEWARPA,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaListPages(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetValidModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertRefModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaStripRefModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaRestoreModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaInfo(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStats(
        dewa: *mut L_DEWARPA,
        pnnone: *mut l_int32,
        pnvsuccess: *mut l_int32,
        pnvvalid: *mut l_int32,
        pnhsuccess: *mut l_int32,
        pnhvalid: *mut l_int32,
        pnref: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaShowArrays(
        dewa: *mut L_DEWARPA,
        scalefact: l_float32,
        first: l_int32,
        last: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpDebug(
        dew: *mut L_DEWARP,
        subdirs: *const ::std::os::raw::c_char,
        index: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpShowResults(
        dewa: *mut L_DEWARPA,
        sa: *mut SARRAY,
        boxa: *mut BOXA,
        firstpage: l_int32,
        lastpage: l_int32,
        pdfout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaCreate(n: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromDArray(
        darray: *mut l_float64,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaMakeSequence(
        startval: l_float64,
        increment: l_float64,
        size: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaDestroy(pda: *mut *mut L_DNA);
}
extern "C" {
    pub fn l_dnaCopy(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaClone(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaEmpty(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaAddNumber(da: *mut L_DNA, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaInsertNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaRemoveNumber(da: *mut L_DNA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaReplaceNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetCount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetCount(da: *mut L_DNA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetDValue(da: *mut L_DNA, index: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIValue(da: *mut L_DNA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetValue(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaShiftValue(da: *mut L_DNA, index: l_int32, diff: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIArray(da: *mut L_DNA) -> *mut l_int32;
}
extern "C" {
    pub fn l_dnaGetDArray(da: *mut L_DNA, copyflag: l_int32) -> *mut l_float64;
}
extern "C" {
    pub fn l_dnaGetParameters(
        da: *mut L_DNA,
        pstartx: *mut l_float64,
        pdelx: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetParameters(da: *mut L_DNA, startx: l_float64, delx: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaCopyParameters(dad: *mut L_DNA, das: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadStream(fp: *mut FILE) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadMem(data: *const l_uint8, size: usize) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaWrite(filename: *const ::std::os::raw::c_char, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStream(fp: *mut FILE, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStderr(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaCreate(n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaCreateFull(nptr: l_int32, n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaTruncate(daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaDestroy(pdaa: *mut *mut L_DNAA);
}
extern "C" {
    pub fn l_dnaaAddDna(daa: *mut L_DNAA, da: *mut L_DNA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDnaCount(daa: *mut L_DNAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetNumberCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDna(daa: *mut L_DNAA, index: l_int32, accessflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaaReplaceDna(daa: *mut L_DNAA, index: l_int32, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetValue(daa: *mut L_DNAA, i: l_int32, j: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaAddNumber(daa: *mut L_DNAA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadStream(fp: *mut FILE) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadMem(data: *const l_uint8, size: usize) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaWrite(filename: *const ::std::os::raw::c_char, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteStream(fp: *mut FILE, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaJoin(dad: *mut L_DNA, das: *mut L_DNA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaFlattenToDna(daa: *mut L_DNAA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaSelectRange(das: *mut L_DNA, first: l_int32, last: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaConvertToNuma(da: *mut L_DNA) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToDna(na: *mut NUMA) -> *mut L_DNA;
}
extern "C" {
    pub fn pixConvertDataToDna(pix: *mut PIX) -> *mut L_DNA;
}
extern "C" {
    pub fn l_asetCreateFromDna(da: *mut L_DNA) -> *mut L_ASET;
}
extern "C" {
    pub fn l_dnaRemoveDupsByAset(das: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromDna(da: *mut L_DNA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_dnaRemoveDupsByHmap(
        das: *mut L_DNA,
        pdad: *mut *mut L_DNA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_dnaMakeHistoByHmap(
        das: *mut L_DNA,
        pdav: *mut *mut L_DNA,
        pdac: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaDiffAdjValues(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashCreate(nbuckets: l_int32, initsize: l_int32) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaHashDestroy(pdahash: *mut *mut L_DNAHASH);
}
extern "C" {
    pub fn l_dnaHashGetDna(dahash: *mut L_DNAHASH, key: l_uint64, copyflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashAdd(dahash: *mut L_DNAHASH, key: l_uint64, value: l_float64) -> l_ok;
}
extern "C" {
    pub fn pixMorphDwa_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_2(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSobelEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTwoSidedEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureEdgeSmoothness(
        pixs: *mut PIX,
        side: l_int32,
        minjump: l_int32,
        minreversal: l_int32,
        pjpl: *mut l_float32,
        pjspl: *mut l_float32,
        prpl: *mut l_float32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetEdgeProfile(
        pixs: *mut PIX,
        side: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetLastOffPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLastOnPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn encodeBase64(
        inarray: *const l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeBase64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85(
        inarray: *const l_uint8,
        insize: usize,
        poutsize: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85(
        inarray: *const ::std::os::raw::c_char,
        insize: usize,
        poutsize: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85WithComp(
        indata: *const l_uint8,
        insize: usize,
        poutsize: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85WithComp(
        instr: *const ::std::os::raw::c_char,
        insize: usize,
        poutsize: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn reformatPacked64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        leadspace: l_int32,
        linechars: l_int32,
        addquotes: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixGammaTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCWithAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaGammaTRC(gamma: l_float32, minval: l_int32, maxval: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixContrastTRC(pixd: *mut PIX, pixs: *mut PIX, factor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaContrastTRC(factor: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn pixEqualizeTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        fract: l_float32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaEqualizeTRC(pix: *mut PIX, fract: l_float32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTRCMap(pixs: *mut PIX, pixm: *mut PIX, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixTRCMapGeneral(
        pixs: *mut PIX,
        pixm: *mut PIX,
        nar: *mut NUMA,
        nag: *mut NUMA,
        nab: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUnsharpMasking(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGrayFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray1D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray2D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixModifyHue(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixModifySaturation(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureSaturation(pixs: *mut PIX, factor: l_int32, psat: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixModifyBrightness(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMosaicColorShiftRGB(
        pixs: *mut PIX,
        roff: l_float32,
        goff: l_float32,
        boff: l_float32,
        delta: l_float32,
        nincr: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorShiftRGB(
        pixs: *mut PIX,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDarkenGray(
        pixd: *mut PIX,
        pixs: *mut PIX,
        thresh: l_int32,
        satlimit: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultConstantColor(
        pixs: *mut PIX,
        rfact: l_float32,
        gfact: l_float32,
        bfact: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultMatrixColor(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHalfEdgeByBandpass(
        pixs: *mut PIX,
        sm1h: l_int32,
        sm1v: l_int32,
        sm2h: l_int32,
        sm2v: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHMTDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFHMTGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixItalicWords(
        pixs: *mut PIX,
        boxaw: *mut BOXA,
        pixw: *mut PIX,
        pboxa: *mut *mut BOXA,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOrientCorrect(
        pixs: *mut PIX,
        minupconf: l_float32,
        minratio: l_float32,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        protation: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOrientDetect(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeOrientDecision(
        upconf: l_float32,
        leftconf: l_float32,
        minupconf: l_float32,
        minratio: l_float32,
        porient: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUpDownDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMirrorDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixCreate(width: l_int32, height: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCreateTemplate(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixClone(fpix: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCopy(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixDestroy(pfpix: *mut *mut FPIX);
}
extern "C" {
    pub fn fpixGetDimensions(fpix: *mut FPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetDimensions(fpix: *mut FPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetWpl(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixSetWpl(fpix: *mut FPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetResolution(fpix: *mut FPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetResolution(fpix: *mut FPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixCopyResolution(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixGetData(fpix: *mut FPIX) -> *mut l_float32;
}
extern "C" {
    pub fn fpixSetData(fpix: *mut FPIX, data: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixGetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixSetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixaCreate(n: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaCopy(fpixa: *mut FPIXA, copyflag: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaDestroy(pfpixa: *mut *mut FPIXA);
}
extern "C" {
    pub fn fpixaAddFPix(fpixa: *mut FPIXA, fpix: *mut FPIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetCount(fpixa: *mut FPIXA) -> l_int32;
}
extern "C" {
    pub fn fpixaGetFPix(fpixa: *mut FPIXA, index: l_int32, accesstype: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixaGetFPixDimensions(
        fpixa: *mut FPIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaGetData(fpixa: *mut FPIXA, index: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn fpixaGetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaSetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        val: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixCreate(width: l_int32, height: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCreateTemplate(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixClone(dpix: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCopy(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixDestroy(pdpix: *mut *mut DPIX);
}
extern "C" {
    pub fn dpixGetDimensions(dpix: *mut DPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetDimensions(dpix: *mut DPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetWpl(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixSetWpl(dpix: *mut DPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetResolution(dpix: *mut DPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetResolution(dpix: *mut DPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixCopyResolution(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixGetData(dpix: *mut DPIX) -> *mut l_float64;
}
extern "C" {
    pub fn dpixSetData(dpix: *mut DPIX, data: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixGetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixSetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixRead(filename: *const ::std::os::raw::c_char) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadStream(fp: *mut FILE) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadMem(data: *const l_uint8, size: usize) -> *mut FPIX;
}
extern "C" {
    pub fn fpixWrite(filename: *const ::std::os::raw::c_char, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteStream(fp: *mut FILE, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixEndianByteSwap(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn dpixRead(filename: *const ::std::os::raw::c_char) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadStream(fp: *mut FILE) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadMem(data: *const l_uint8, size: usize) -> *mut DPIX;
}
extern "C" {
    pub fn dpixWrite(filename: *const ::std::os::raw::c_char, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteStream(fp: *mut FILE, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixEndianByteSwap(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn fpixPrintStream(fp: *mut FILE, fpix: *mut FPIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertToFPix(pixs: *mut PIX, ncomps: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvertToDPix(pixs: *mut PIX, ncomps: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixConvertToPix(
        fpixs: *mut FPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixDisplayMaxDynamicRange(fpixs: *mut FPIX) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvertToDPix(fpix: *mut FPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixConvertToPix(
        dpixs: *mut DPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn dpixConvertToFPix(dpix: *mut DPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixGetMin(
        fpix: *mut FPIX,
        pminval: *mut l_float32,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixGetMax(
        fpix: *mut FPIX,
        pmaxval: *mut l_float32,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMin(
        dpix: *mut DPIX,
        pminval: *mut l_float64,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMax(
        dpix: *mut DPIX,
        pmaxval: *mut l_float64,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixScaleByInteger(fpixs: *mut FPIX, factor: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn dpixScaleByInteger(dpixs: *mut DPIX, factor: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixLinearCombination(
        fpixd: *mut FPIX,
        fpixs1: *mut FPIX,
        fpixs2: *mut FPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMultConstant(fpix: *mut FPIX, addc: l_float32, multc: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixLinearCombination(
        dpixd: *mut DPIX,
        dpixs1: *mut DPIX,
        dpixs2: *mut DPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut DPIX;
}
extern "C" {
    pub fn dpixAddMultConstant(dpix: *mut DPIX, addc: l_float64, multc: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixSetAllArbitrary(fpix: *mut FPIX, inval: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixSetAllArbitrary(dpix: *mut DPIX, inval: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixAddBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRemoveBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMirroredBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddContinuedBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddSlopeBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRasterop(
        fpixd: *mut FPIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        fpixs: *mut FPIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixRotateOrth(fpixs: *mut FPIX, quads: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate180(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate90(fpixs: *mut FPIX, direction: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipLR(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipTB(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffinePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffine(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjectivePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjective(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn linearInterpolatePixelFloat(
        datas: *mut l_float32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        inval: l_float32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixThresholdToPix(fpix: *mut FPIX, thresh: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixComponentFunction(
        pix: *mut PIX,
        rnum: l_float32,
        gnum: l_float32,
        bnum: l_float32,
        rdenom: l_float32,
        gdenom: l_float32,
        bdenom: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixReadStreamGif(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemGif(cdata: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamGif(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemGif(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn gplotCreate(
        rootname: *const ::std::os::raw::c_char,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotDestroy(pgplot: *mut *mut GPLOT);
}
extern "C" {
    pub fn gplotAddPlot(
        gplot: *mut GPLOT,
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        plotlabel: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSetScaling(gplot: *mut GPLOT, scaling: l_int32) -> l_ok;
}
extern "C" {
    pub fn gplotMakeOutputPix(gplot: *mut GPLOT) -> *mut PIX;
}
extern "C" {
    pub fn gplotMakeOutput(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenCommandFile(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenDataFiles(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotSimple1(
        na: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimple2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimpleN(
        naa: *mut NUMAA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimplePix1(na: *mut NUMA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        title: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePixN(naa: *mut NUMAA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimpleXY1(
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXY2(
        nax: *mut NUMA,
        nay1: *mut NUMA,
        nay2: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXYN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotGeneralPix1(
        na: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPixN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotRead(filename: *const ::std::os::raw::c_char) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotWrite(filename: *const ::std::os::raw::c_char, gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn generatePtaLine(x1: l_int32, y1: l_int32, x2: l_int32, y2: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaWideLine(
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBox(box_: *mut BOX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBoxa(boxa: *mut BOXA, width: l_int32, removedups: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBox(
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaaBoxa(boxa: *mut BOXA) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaPolyline(
        ptas: *mut PTA,
        width: l_int32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaGrid(
        w: l_int32,
        h: l_int32,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn convertPtaLineTo4cc(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledCircle(radius: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledSquare(side: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaLineFromPt(
        x: l_int32,
        y: l_int32,
        length: l_float64,
        radang: l_float64,
    ) -> *mut PTA;
}
extern "C" {
    pub fn locatePtRadially(
        xr: l_int32,
        yr: l_int32,
        dist: l_float64,
        radang: l_float64,
        px: *mut l_float64,
        py: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPlotFromNuma(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNuma(
        na: *mut NUMA,
        size: l_int32,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPlotFromNumaGen(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNumaGen(
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPta(pix: *mut PIX, pta: *mut PTA, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaArb(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaBlend(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineArb(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineBlend(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBox(pix: *mut PIX, box_: *mut BOX, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxa(pix: *mut PIX, boxa: *mut BOXA, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBox(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashMaskArb(
        pix: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxa(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolyline(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        op: l_int32,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineArb(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineBlend(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderGridArb(
        pix: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderRandomCmapPtaa(
        pix: *mut PIX,
        ptaa: *mut PTAA,
        polyflag: l_int32,
        width: l_int32,
        closeflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderPolygon(
        ptas: *mut PTA,
        width: l_int32,
        pxmin: *mut l_int32,
        pymin: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFillPolygon(pixs: *mut PIX, pta: *mut PTA, xmin: l_int32, ymin: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderContours(
        pixs: *mut PIX,
        startval: l_int32,
        incr: l_int32,
        outdepth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixAutoRenderContours(fpix: *mut FPIX, ncontours: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn fpixRenderContours(fpixs: *mut FPIX, incr: l_float32, proxim: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixGeneratePtaBoundary(pixs: *mut PIX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn pixErodeGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinary(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinarySpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ditherToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        bufs1: *mut l_uint32,
        bufs2: *mut l_uint32,
        lowerclip: l_int32,
        upperclip: l_int32,
        lastlineflag: l_int32,
    );
}
extern "C" {
    pub fn pixThresholdToBinary(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn thresholdToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        lines: *mut l_uint32,
        d: l_int32,
        thresh: l_int32,
    );
}
extern "C" {
    pub fn pixVarThresholdToBinary(pixs: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinary(pixs: *mut PIX, pixm: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinaryGen(
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByValue(pixs: *mut PIX, val: l_int32, usecmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByBand(
        pixs: *mut PIX,
        lower: l_int32,
        upper: l_int32,
        inband: l_int32,
        usecmap: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bpp(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bppSpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo2bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo4bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdOn8bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdGrayArb(
        pixs: *mut PIX,
        edgevals: *const ::std::os::raw::c_char,
        outdepth: l_int32,
        use_average: l_int32,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeGrayQuantIndexTable(nlevels: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn makeGrayQuantTableArb(
        na: *mut NUMA,
        outdepth: l_int32,
        ptab: *mut *mut l_int32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenerateMaskByBand32(
        pixs: *mut PIX,
        refval: l_uint32,
        delm: l_int32,
        delp: l_int32,
        fractm: l_float32,
        fractp: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByDiscr32(
        pixs: *mut PIX,
        refval1: l_uint32,
        refval2: l_uint32,
        distflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromHisto(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        minfract: l_float32,
        maxsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromCmap(pixs: *mut PIX, cmap: *mut PIXCMAP, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn l_hmapCreate(ninit: l_int32, maxocc: l_int32) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_hmapDestroy(phmap: *mut *mut L_HASHMAP);
}
extern "C" {
    pub fn l_hmapLookup(
        hmap: *mut L_HASHMAP,
        key: l_uint64,
        val: l_uint64,
        op: l_int32,
    ) -> *mut L_HASHITEM;
}
extern "C" {
    pub fn l_hmapRehash(hmap: *mut L_HASHMAP) -> l_ok;
}
extern "C" {
    pub fn lheapCreate(n: l_int32, direction: l_int32) -> *mut L_HEAP;
}
extern "C" {
    pub fn lheapDestroy(plh: *mut *mut L_HEAP, freeflag: l_int32);
}
extern "C" {
    pub fn lheapAdd(lh: *mut L_HEAP, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lheapRemove(lh: *mut L_HEAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapGetCount(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapGetElement(lh: *mut L_HEAP, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapSort(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapSortStrictOrder(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapPrint(fp: *mut FILE, lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn jbRankHausInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        size: l_int32,
        rank: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInitWithoutComponents(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbAddPages(classer: *mut JBCLASSER, safiles: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn jbAddPage(classer: *mut JBCLASSER, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn jbAddPageComponents(
        classer: *mut JBCLASSER,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbClassifyRankHaus(classer: *mut JBCLASSER, boxa: *mut BOXA, pixas: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        area1: l_int32,
        area3: l_int32,
        rank: l_float32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyCorrelation(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbGetComponents(
        pixs: *mut PIX,
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordMaskByDilation(
        pixs: *mut PIX,
        ppixm: *mut *mut PIX,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordBoxesByDilation(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxa: *mut *mut BOXA,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbAccumulateComposites(
        pixaa: *mut PIXAA,
        pna: *mut *mut NUMA,
        pptat: *mut *mut PTA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn jbTemplatesFromComposites(pixac: *mut PIXA, na: *mut NUMA) -> *mut PIXA;
}
extern "C" {
    pub fn jbClasserCreate(method: l_int32, components: l_int32) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbClasserDestroy(pclasser: *mut *mut JBCLASSER);
}
extern "C" {
    pub fn jbDataSave(classer: *mut JBCLASSER) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataDestroy(pdata: *mut *mut JBDATA);
}
extern "C" {
    pub fn jbDataWrite(rootout: *const ::std::os::raw::c_char, jbdata: *mut JBDATA) -> l_ok;
}
extern "C" {
    pub fn jbDataRead(rootname: *const ::std::os::raw::c_char) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataRender(data: *mut JBDATA, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn jbGetULCorners(classer: *mut JBCLASSER, pixs: *mut PIX, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn jbGetLLCorners(classer: *mut JBCLASSER) -> l_ok;
}
extern "C" {
    pub fn readHeaderJp2k(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJp2k(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemJp2k(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJp2kResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadJp2k(
        filename: *const ::std::os::raw::c_char,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJp2k(
        fp: *mut FILE,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteJp2k(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJp2k(
        fp: *mut FILE,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        codec: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJp2k(
        data: *const l_uint8,
        size: usize,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemJp2k(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadJpeg(
        filename: *const ::std::os::raw::c_char,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJpeg(
        fp: *mut FILE,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderJpeg(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJpeg(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJpegResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fgetJpegComment(fp: *mut FILE, pcomment: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn pixWriteJpeg(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJpeg(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJpeg(
        data: *const l_uint8,
        size: usize,
        cmflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemJpeg(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readResolutionMemJpeg(
        data: *const l_uint8,
        size: usize,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemJpeg(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetChromaSampling(pix: *mut PIX, sampling: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelCreate(height: l_int32, width: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDestroy(pkel: *mut *mut L_KERNEL);
}
extern "C" {
    pub fn kernelCopy(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelGetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetElement(kel: *mut L_KERNEL, row: l_int32, col: l_int32, val: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn kernelGetParameters(
        kel: *mut L_KERNEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetOrigin(kel: *mut L_KERNEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelGetSum(kel: *mut L_KERNEL, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelGetMinMax(kel: *mut L_KERNEL, pmin: *mut l_float32, pmax: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelNormalize(kels: *mut L_KERNEL, normsum: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelInvert(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn create2dFloatArray(sy: l_int32, sx: l_int32) -> *mut *mut l_float32;
}
extern "C" {
    pub fn kernelRead(fname: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelReadStream(fp: *mut FILE) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelWrite(fname: *const ::std::os::raw::c_char, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelWriteStream(fp: *mut FILE, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelCreateFromString(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        kdata: *const ::std::os::raw::c_char,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromPix(pix: *mut PIX, cy: l_int32, cx: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDisplayInPix(kel: *mut L_KERNEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn parseStringForNumbers(
        str_: *const ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn makeFlatKernel(
        height: l_int32,
        width: l_int32,
        cy: l_int32,
        cx: l_int32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernelSep(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
        pkelx: *mut *mut L_KERNEL,
        pkely: *mut *mut L_KERNEL,
    ) -> l_ok;
}
extern "C" {
    pub fn makeDoGKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        ratio: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn getImagelibVersions() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listDestroy(phead: *mut *mut DLLIST);
}
extern "C" {
    pub fn listAddToHead(phead: *mut *mut DLLIST, data: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn listAddToTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertBefore(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertAfter(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listRemoveElement(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromHead(phead: *mut *mut DLLIST) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listFindElement(head: *mut DLLIST, data: *mut ::std::os::raw::c_void) -> *mut DLLIST;
}
extern "C" {
    pub fn listFindTail(head: *mut DLLIST) -> *mut DLLIST;
}
extern "C" {
    pub fn listGetCount(head: *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listReverse(phead: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn listJoin(phead1: *mut *mut DLLIST, phead2: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn l_amapCreate(keytype: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn l_amapFind(m: *mut L_AMAP, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_amapInsert(m: *mut L_AMAP, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_amapDelete(m: *mut L_AMAP, key: RB_TYPE);
}
extern "C" {
    pub fn l_amapDestroy(pm: *mut *mut L_AMAP);
}
extern "C" {
    pub fn l_amapGetFirst(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetNext(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetLast(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetPrev(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapSize(m: *mut L_AMAP) -> l_int32;
}
extern "C" {
    pub fn l_asetCreate(keytype: l_int32) -> *mut L_ASET;
}
extern "C" {
    pub fn l_asetFind(s: *mut L_ASET, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_asetInsert(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDelete(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDestroy(ps: *mut *mut L_ASET);
}
extern "C" {
    pub fn l_asetGetFirst(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetNext(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetLast(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetPrev(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetSize(s: *mut L_ASET) -> l_int32;
}
extern "C" {
    pub fn generateBinaryMaze(
        w: l_int32,
        h: l_int32,
        xi: l_int32,
        yi: l_int32,
        wallps: l_float32,
        ranis: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSearchBinaryMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixSearchGrayMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDilate(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixErode(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHMT(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpen(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixClose(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafe(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrick(pixd: *mut PIX, pixs: *mut PIX, hsize: l_int32, vsize: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selectComposableSels(
        size: l_int32,
        direction: l_int32,
        psel1: *mut *mut SEL,
        psel2: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selectComposableSizes(
        size: l_int32,
        pfactor1: *mut l_int32,
        pfactor2: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn resetMorphBoundaryCondition(bc: l_int32);
}
extern "C" {
    pub fn getMorphBorderPixelColor(type_: l_int32, depth: l_int32) -> l_uint32;
}
extern "C" {
    pub fn pixExtractBoundary(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceByComponent(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByComponent(
        pixas: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixMorphSequenceByRegion(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByRegion(
        pixs: *mut PIX,
        pixam: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixUnionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixIntersectionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectiveConnCompFill(
        pixs: *mut PIX,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        dsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        color: l_uint32,
        scale: l_float32,
        nlevels: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtendByMorph(
        pixas: *mut PIXA,
        type_: l_int32,
        niters: l_int32,
        sel: *mut SEL,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaExtendByScaling(
        pixas: *mut PIXA,
        nasc: *mut NUMA,
        type_: l_int32,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSeedfillMorph(
        pixs: *mut PIX,
        pixm: *mut PIX,
        maxiters: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunHistogramMorph(
        pixs: *mut PIX,
        runtype: l_int32,
        direction: l_int32,
        maxsize: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixTophat(pixs: *mut PIX, hsize: l_int32, vsize: l_int32, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixHDome(pixs: *mut PIX, height: l_int32, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFastTophat(
        pixs: *mut PIX,
        xsize: l_int32,
        ysize: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphGradient(
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
        smoothing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaCentroids(pixa: *mut PIXA) -> *mut PTA;
}
extern "C" {
    pub fn pixCentroid(
        pix: *mut PIX,
        centtab: *mut l_int32,
        sumtab: *mut l_int32,
        pxave: *mut l_float32,
        pyave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getExtendedCompositeParameters(
        size: l_int32,
        pn: *mut l_int32,
        pextra: *mut l_int32,
        pactualsize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn morphSequenceVerify(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixGrayMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaCreate(n: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromFArray(
        farray: *mut l_float32,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromString(str_: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaDestroy(pna: *mut *mut NUMA);
}
extern "C" {
    pub fn numaCopy(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaClone(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaEmpty(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaAddNumber(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaInsertNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaRemoveNumber(na: *mut NUMA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaReplaceNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetCount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSetCount(na: *mut NUMA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetFValue(na: *mut NUMA, index: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIValue(na: *mut NUMA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaSetValue(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaShiftValue(na: *mut NUMA, index: l_int32, diff: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIArray(na: *mut NUMA) -> *mut l_int32;
}
extern "C" {
    pub fn numaGetFArray(na: *mut NUMA, copyflag: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn numaGetParameters(na: *mut NUMA, pstartx: *mut l_float32, pdelx: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn numaSetParameters(na: *mut NUMA, startx: l_float32, delx: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaCopyParameters(nad: *mut NUMA, nas: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaConvertToSarray(
        na: *mut NUMA,
        size1: l_int32,
        size2: l_int32,
        addzeros: l_int32,
        type_: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn numaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadStream(fp: *mut FILE) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadMem(data: *const l_uint8, size: usize) -> *mut NUMA;
}
extern "C" {
    pub fn numaWriteDebug(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWrite(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStream(fp: *mut FILE, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStderr(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaCreate(n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCreateFull(nptr: l_int32, n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaTruncate(naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaDestroy(pnaa: *mut *mut NUMAA);
}
extern "C" {
    pub fn numaaAddNuma(naa: *mut NUMAA, na: *mut NUMA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaGetCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumaCount(naa: *mut NUMAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumberCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetPtrArray(naa: *mut NUMAA) -> *mut *mut NUMA;
}
extern "C" {
    pub fn numaaGetNuma(naa: *mut NUMAA, index: l_int32, accessflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaaReplaceNuma(naa: *mut NUMAA, index: l_int32, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaGetValue(
        naa: *mut NUMAA,
        i: l_int32,
        j: l_int32,
        pfval: *mut l_float32,
        pival: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaaAddNumber(naa: *mut NUMAA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadStream(fp: *mut FILE) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadMem(data: *const l_uint8, size: usize) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaWrite(filename: *const ::std::os::raw::c_char, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteStream(fp: *mut FILE, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaArithOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaLogicalOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaInvert(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimilar(
        na1: *mut NUMA,
        na2: *mut NUMA,
        maxdiff: l_float32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaAddToNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMin(na: *mut NUMA, pminval: *mut l_float32, piminloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMax(na: *mut NUMA, pmaxval: *mut l_float32, pimaxloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetSum(na: *mut NUMA, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetPartialSums(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSumOnInterval(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHasOnlyIntegers(na: *mut NUMA, pallints: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMean(na: *mut NUMA, pave: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanAbsval(na: *mut NUMA, paveabs: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaSubsample(nas: *mut NUMA, subfactor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeDelta(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeSequence(startval: l_float32, increment: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeConstant(val: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeAbsval(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        val: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSpecifiedBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRemoveBorder(nas: *mut NUMA, left: l_int32, right: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountNonzeroRuns(na: *mut NUMA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetNonzeroRange(
        na: *mut NUMA,
        eps: l_float32,
        pfirst: *mut l_int32,
        plast: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetCountRelativeToZero(na: *mut NUMA, type_: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaClipToInterval(nas: *mut NUMA, first: l_int32, last: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeThresholdIndicator(
        nas: *mut NUMA,
        thresh: l_float32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaUniformSampling(nas: *mut NUMA, nsamp: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaReverse(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaLowPassIntervals(nas: *mut NUMA, thresh: l_float32, maxn: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaThresholdEdges(
        nas: *mut NUMA,
        thresh1: l_float32,
        thresh2: l_float32,
        maxn: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSpanValues(
        na: *mut NUMA,
        span: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetEdgeValues(
        na: *mut NUMA,
        edge: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
        psign: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxVal(
        startx: l_float32,
        deltax: l_float32,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxVal(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateEqxInterval(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFitMax(
        na: *mut NUMA,
        pmaxval: *mut l_float32,
        naloc: *mut NUMA,
        pmaxloc: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDifferentiateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaIntegrateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortGeneral(
        na: *mut NUMA,
        pnasort: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        pnainvert: *mut *mut NUMA,
        sortorder: l_int32,
        sorttype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortIndexAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaChooseSortType(nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSort(naout: *mut NUMA, nain: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaBinSort(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSortIndex(na: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetBinSortIndex(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortByIndex(nas: *mut NUMA, naindex: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaIsSorted(nas: *mut NUMA, sortorder: l_int32, psorted: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSortPair(
        nax: *mut NUMA,
        nay: *mut NUMA,
        sortorder: l_int32,
        pnasx: *mut *mut NUMA,
        pnasy: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInvertMap(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSorted(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaFindSortedLoc(na: *mut NUMA, val: l_float32, pindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaPseudorandomSequence(size: l_int32, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaRandomPermutation(nas: *mut NUMA, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetRankValue(
        na: *mut NUMA,
        fract: l_float32,
        nasort: *mut NUMA,
        usebins: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMedian(na: *mut NUMA, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetBinnedMedian(na: *mut NUMA, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanDevFromMedian(na: *mut NUMA, med: l_float32, pdev: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMedianDevFromMedian(
        na: *mut NUMA,
        pmed: *mut l_float32,
        pdev: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMode(na: *mut NUMA, pval: *mut l_float32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaJoin(nad: *mut NUMA, nas: *mut NUMA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaJoin(naad: *mut NUMAA, naas: *mut NUMAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaFlattenToNuma(naa: *mut NUMAA) -> *mut NUMA;
}
extern "C" {
    pub fn numaErode(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaDilate(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaOpen(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaClose(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaTransform(nas: *mut NUMA, shift: l_float32, scale: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimpleStats(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        pmean: *mut l_float32,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedStats(
        nas: *mut NUMA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMean(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedMeanSquare(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedVariance(
        nam: *mut NUMA,
        nams: *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMedian(nas: *mut NUMA, halfwin: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToInt(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pbinsize: *mut l_int32,
        pbinstart: *mut l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramAuto(na: *mut NUMA, maxbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramClipped(
        na: *mut NUMA,
        binsize: l_float32,
        maxsize: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRebinHistogram(nas: *mut NUMA, newsize: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaNormalizeHistogram(nas: *mut NUMA, tsum: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetStatsUsingHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
        pmean: *mut l_float32,
        pvariance: *mut l_float32,
        pmedian: *mut l_float32,
        rank: l_float32,
        prval: *mut l_float32,
        phisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStats(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStatsOnInterval(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        ifirst: l_int32,
        ilast: l_int32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaMakeRankFromHistogram(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetRankFromVal(
        na: *mut NUMA,
        rval: l_float32,
        prank: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetValFromRank(
        na: *mut NUMA,
        rank: l_float32,
        prval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeSortedInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeHistoInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
        pnarank: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetRankBinValues(na: *mut NUMA, nbins: l_int32, pnam: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaGetUniformBinSizes(ntotal: l_int32, nbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSplitDistribution(
        na: *mut NUMA,
        scorefract: l_float32,
        psplitindex: *mut l_int32,
        pave1: *mut l_float32,
        pave2: *mut l_float32,
        pnum1: *mut l_float32,
        pnum2: *mut l_float32,
        pnascore: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn grayHistogramsToEMD(naa1: *mut NUMAA, naa2: *mut NUMAA, pnad: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaEarthMoverDistance(na1: *mut NUMA, na2: *mut NUMA, pdist: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn grayInterHistogramStats(
        naa: *mut NUMAA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFindPeaks(
        nas: *mut NUMA,
        nmax: l_int32,
        fract1: l_float32,
        fract2: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindExtrema(nas: *mut NUMA, delta: l_float32, pnav: *mut *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindLocForThreshold(
        na: *mut NUMA,
        skip: l_int32,
        pthresh: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCountReversals(
        nas: *mut NUMA,
        minreversal: l_float32,
        pnr: *mut l_int32,
        prd: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSelectCrossingThreshold(
        nax: *mut NUMA,
        nay: *mut NUMA,
        estthresh: l_float32,
        pbestthresh: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCrossingsByThreshold(nax: *mut NUMA, nay: *mut NUMA, thresh: l_float32)
        -> *mut NUMA;
}
extern "C" {
    pub fn numaCrossingsByPeaks(nax: *mut NUMA, nay: *mut NUMA, delta: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaEvalBestHaarParameters(
        nas: *mut NUMA,
        relweight: l_float32,
        nwidth: l_int32,
        nshift: l_int32,
        minwidth: l_float32,
        maxwidth: l_float32,
        pbestwidth: *mut l_float32,
        pbestshift: *mut l_float32,
        pbestscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaEvalHaarSum(
        nas: *mut NUMA,
        width: l_float32,
        shift: l_float32,
        relweight: l_float32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn genConstrainedNumaInRange(
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRegionsBinary(
        pixs: *mut PIX,
        ppixhm: *mut *mut PIX,
        ppixtm: *mut *mut PIX,
        ppixtb: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextlineMask(
        pixs: *mut PIX,
        ppixvws: *mut *mut PIX,
        ptlfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextblockMask(pixs: *mut PIX, pixvws: *mut PIX, pixadb: *mut PIXA) -> *mut PIX;
}
extern "C" {
    pub fn pixFindPageForeground(
        pixs: *mut PIX,
        threshold: l_int32,
        mindist: l_int32,
        erasedist: l_int32,
        showmorph: l_int32,
        pixac: *mut PIXAC,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSplitIntoCharacters(
        pixs: *mut PIX,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdebug: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitComponentWithProfile(
        pixs: *mut PIX,
        delta: l_int32,
        mindel: l_int32,
        ppixdebug: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixExtractTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        minw: l_int32,
        minh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixExtractRawTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixCountTextColumns(
        pixs: *mut PIX,
        deltafract: l_float32,
        peakfract: l_float32,
        clipfract: l_float32,
        pncols: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfText(
        pixs: *mut PIX,
        box_: *mut BOX,
        pistext: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindThreshFgExtent(
        pixs: *mut PIX,
        thresh: l_int32,
        ptop: *mut l_int32,
        pbot: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfTable(
        pixs: *mut PIX,
        box_: *mut BOX,
        orient: l_int32,
        pscore: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPrepare1bpp(
        pixs: *mut PIX,
        box_: *mut BOX,
        cropfract: l_float32,
        outres: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEstimateBackground(
        pixs: *mut PIX,
        darkthresh: l_int32,
        edgecrop: l_float32,
        pbg: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargeRectangles(
        pixs: *mut PIX,
        polarity: l_int32,
        nrect: l_int32,
        pboxa: *mut *mut BOXA,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargestRectangle(
        pixs: *mut PIX,
        polarity: l_int32,
        pbox: *mut *mut BOX,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleInCC(
        pixs: *mut PIX,
        boxs: *mut BOX,
        fract: l_float32,
        dir: l_int32,
        select: l_int32,
        debug: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixAutoPhotoinvert(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixm: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetSelectCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayRegionsCmap(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn addColorizedGrayToCmap(
        cmap: *mut PIXCMAP,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetSelectMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn parseForProtos(
        filein: *const ::std::os::raw::c_char,
        prestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn partifyFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn partifyPixac(
        pixac: *mut PIXAC,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetWhiteblocks(
        boxas: *mut BOXA,
        box_: *mut BOX,
        sortflag: l_int32,
        maxboxes: l_int32,
        maxoverlap: l_float32,
        maxperim: l_int32,
        fract: l_float32,
        maxpops: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPruneSortedOnOverlap(boxas: *mut BOXA, maxoverlap: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn convertFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdf(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdfData(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn selectDefaultPdfEncoding(pix: *mut PIX, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdf(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdfData(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledToPdfData(
        fname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdf(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdfData(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdf(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdf(
        imdata: *mut l_uint8,
        size: usize,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfData(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdfData(
        imdata: *mut l_uint8,
        size: usize,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdf(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPdf(
        fp: *mut FILE,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPdf(
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        baa: *mut BOXAA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertNumberedMasksToBoxaa(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn convertToPdfSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfDataSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfDataSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn concatenatePdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdf(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdf(pa: *mut L_PTRA, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn concatenatePdfToData(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdfToData(
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfData(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdfToData(
        pa_data: *mut L_PTRA,
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPdf(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIDataForPdf(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIData(
        fname: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateDataPdf(
        fname: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegDataMem(
        data: *mut l_uint8,
        nbytes: usize,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateG4Data(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn pixGenerateCIData(
        pixs: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn cidConvertToPdfData(
        cid: *mut L_COMP_DATA,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn l_CIDataDestroy(pcid: *mut *mut L_COMP_DATA);
}
extern "C" {
    pub fn l_pdfSetG4ImageMask(flag: l_int32);
}
extern "C" {
    pub fn l_pdfSetDateAndVersion(flag: l_int32);
}
extern "C" {
    pub fn setPixMemoryManager(allocator: alloc_fn, deallocator: dealloc_fn);
}
extern "C" {
    pub fn pixCreate(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateNoInit(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplate(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplateNoInit(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateWithCmap(
        width: l_int32,
        height: l_int32,
        depth: l_int32,
        initcolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateHeader(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixClone(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDestroy(ppix: *mut *mut PIX);
}
extern "C" {
    pub fn pixCopy(pixd: *mut PIX, pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeImageData(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixCopyColormap(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixTransferAllData(
        pixd: *mut PIX,
        ppixs: *mut *mut PIX,
        copytext: l_int32,
        copyformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSwapAndDestroy(ppixd: *mut *mut PIX, ppixs: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWidth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWidth(pix: *mut PIX, width: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetHeight(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetHeight(pix: *mut PIX, height: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDepth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetDepth(pix: *mut PIX, depth: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDimensions(
        pix: *const PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetDimensions(pix: *mut PIX, w: l_int32, h: l_int32, d: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyDimensions(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetSpp(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpp(pix: *mut PIX, spp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopySpp(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWpl(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWpl(pix: *mut PIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetXRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetXRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetYRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetYRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetResolution(pix: *const PIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetResolution(pix: *mut PIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyResolution(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixScaleResolution(pix: *mut PIX, xscale: l_float32, yscale: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixGetInputFormat(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetInputFormat(pix: *mut PIX, informat: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyInputFormat(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpecial(pix: *mut PIX, special: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetText(pix: *mut PIX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixSetText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixAddText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixCopyText(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetTextCompNew(pix: *mut PIX, psize: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn pixSetTextCompNew(pix: *mut PIX, data: *const l_uint8, size: usize) -> l_ok;
}
extern "C" {
    pub fn pixGetColormap(pix: *mut PIX) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixSetColormap(pix: *mut PIX, colormap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixDestroyColormap(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetData(pix: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixFreeAndSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixFreeData(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixExtractData(pixs: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixGetLinePtrs(pix: *mut PIX, psize: *mut l_int32) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixSizesEqual(pix1: *const PIX, pix2: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixMaxAspectRatio(pixs: *mut PIX, pratio: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixPrintStreamInfo(
        fp: *mut FILE,
        pix: *const PIX,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixel(pix: *mut PIX, x: l_int32, y: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetPixel(pix: *mut PIX, x: l_int32, y: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetCmapPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRandomPixel(
        pix: *mut PIX,
        pval: *mut l_uint32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClearPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFlipPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn setPixelLow(line: *mut l_uint32, x: l_int32, depth: l_int32, val: l_uint32);
}
extern "C" {
    pub fn pixGetBlackOrWhiteVal(pixs: *mut PIX, op: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixClearAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAllGray(pix: *mut PIX, grayval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetAllArbitrary(pix: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetBlackOrWhite(pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetComponentArbitrary(pix: *mut PIX, comp: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClearInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRectArbitrary(pix: *mut PIX, box_: *mut BOX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixBlendInRect(pixs: *mut PIX, box_: *mut BOX, val: l_uint32, fract: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBits(pix: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBitsBand(pix: *mut PIX, by: l_int32, bh: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetOrClearBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderVal(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderRingVal(pixs: *mut PIX, dist: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyBorder(
        pixd: *mut PIX,
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorder(pixs: *mut PIX, npix: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBlackOrWhiteBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMultipleBlackWhiteBorders(
        pixs: *mut PIX,
        nblack1: l_int32,
        nwhite1: l_int32,
        nblack2: l_int32,
        nwhite2: l_int32,
        nblack3: l_int32,
        nwhite3: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorder(pixs: *mut PIX, npix: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRepeatedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMixedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddContinuedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixShiftAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        shiftx: l_float32,
        shifty: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayLayersRGBA(pixs: *mut PIX, val: l_uint32, maxw: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateRGBImage(pixr: *mut PIX, pixg: *mut PIX, pixb: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBComponent(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBComponentCmap(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCopyRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn composeRGBPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn composeRGBAPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn extractRGBValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractRGBAValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractMinMaxComponent(pixel: l_uint32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBLine(
        pixs: *mut PIX,
        row: l_int32,
        bufr: *mut l_uint8,
        bufg: *mut l_uint8,
        bufb: *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn setLineDataVal(line: *mut l_uint32, j: l_int32, d: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixEndianByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn lineEndianByteSwap(datad: *mut l_uint32, datas: *mut l_uint32, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEndianTwoByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianTwoByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRasterData(pixs: *mut PIX, pdata: *mut *mut l_uint8, pnbytes: *mut usize) -> l_ok;
}
extern "C" {
    pub fn pixInferResolution(pix: *mut PIX, longside: l_float32, pres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixAlphaIsOpaque(pix: *mut PIX, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetupByteProcessing(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut *mut l_uint8;
}
extern "C" {
    pub fn pixCleanupByteProcessing(pix: *mut PIX, lineptrs: *mut *mut l_uint8) -> l_ok;
}
extern "C" {
    pub fn l_setAlphaMaskBorder(val1: l_float32, val2: l_float32);
}
extern "C" {
    pub fn pixSetMasked(pixd: *mut PIX, pixm: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedGeneral(
        pixd: *mut PIX,
        pixm: *mut PIX,
        val: l_uint32,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCombineMasked(pixd: *mut PIX, pixs: *mut PIX, pixm: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixCombineMaskedGeneral(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPaintThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyWithBoxa(pixs: *mut PIX, boxa: *mut BOXA, background: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintSelfThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        searchdir: l_int32,
        mindist: l_int32,
        tilesize: l_int32,
        ntiles: l_int32,
        distblend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeMaskFromVal(pixs: *mut PIX, val: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeMaskFromLUT(pixs: *mut PIX, tab: *mut l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeArbMaskFromRGB(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetUnderTransparency(pixs: *mut PIX, val: l_uint32, debug: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeAlphaFromMask(pixs: *mut PIX, dist: l_int32, pbox: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetColorNearMaskBoundary(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pval: *mut l_uint32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplaySelectedPixels(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sel: *mut SEL,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInvert(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixOr(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAnd(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixXor(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtract(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixZero(pix: *mut PIX, pempty: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixForegroundFraction(pix: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaCountPixels(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixels(pixs: *mut PIX, pcount: *mut l_int32, tab8: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountPixelsInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByRow(pix: *mut PIX, tab8: *mut l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByColumn(pix: *mut PIX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsInRow(
        pix: *mut PIX,
        row: l_int32,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMomentByColumn(pix: *mut PIX, order: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixThresholdPixelSum(
        pix: *mut PIX,
        thresh: l_int32,
        pabove: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePixelSumTab8() -> *mut l_int32;
}
extern "C" {
    pub fn makePixelCentroidTab8() -> *mut l_int32;
}
extern "C" {
    pub fn pixAverageByRow(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageByColumn(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageInRect(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        minval: l_int32,
        maxval: l_int32,
        subsamp: l_int32,
        pave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAverageInRectRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        subsamp: l_int32,
        pave: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceInRect(pix: *mut PIX, box_: *mut BOX, prootvar: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffInRect(
        pix: *mut PIX,
        box_: *mut BOX,
        dir: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffOnLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountArbInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_int32,
        factor: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirroredTiling(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindRepCloseTile(
        pixs: *mut PIX,
        box_: *mut BOX,
        searchdir: l_int32,
        mindist: l_int32,
        tsize: l_int32,
        ntiles: l_int32,
        pboxtile: *mut *mut BOX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetGrayHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramTiled(
        pixs: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixGetColorHistogram(
        pixs: *mut PIX,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColorHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetCmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountRGBColorsByHash(pixs: *mut PIX, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountRGBColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetColorAmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn amapGetCountForColor(amap: *mut L_AMAP, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValue(
        pixs: *mut PIX,
        factor: l_int32,
        rank: l_float32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        pval: *mut l_float32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelAverage(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelStats(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiledRGB(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiled(pixs: *mut PIX, sx: l_int32, sy: l_int32, type_: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixRowStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColumnStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRangeValues(
        pixs: *mut PIX,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetExtremeValue(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        pgrayval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxValueInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pmaxval: *mut l_uint32,
        pxmax: *mut l_int32,
        pymax: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxColorIndex(pixs: *mut PIX, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedComponentRange(
        pixs: *mut PIX,
        nbins: l_int32,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pcarray: *mut *mut l_uint32,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankColorArray(
        pixs: *mut PIX,
        nbins: l_int32,
        type_: l_int32,
        factor: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedColor(
        pixs: *mut PIX,
        pixg: *mut PIX,
        factor: l_int32,
        nbins: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayColorArray(
        carray: *mut l_uint32,
        ncolors: l_int32,
        side: l_int32,
        ncols: l_int32,
        fontsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRankBinByStrip(
        pixs: *mut PIX,
        direction: l_int32,
        size: l_int32,
        nbins: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetAlignedStats(
        pixa: *mut PIXA,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtractColumnFromEachPix(pixa: *mut PIXA, col: l_int32, pixd: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRowStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        colvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColumnStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        rowvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetPixelColumn(pix: *mut PIX, col: l_int32, colvect: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixThresholdForFgBg(
        pixs: *mut PIX,
        factor: l_int32,
        thresh: l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitDistributionFgBg(
        pixs: *mut PIX,
        scorefract: l_float32,
        factor: l_int32,
        pthresh: *mut l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindDimensions(pixa: *mut PIXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixFindAreaPerimRatio(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimToAreaRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimToAreaRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimSizeRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimSizeRatio(pixs: *mut PIX, tab: *mut l_int32, pratio: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFraction(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFraction(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFractionMasked(pixa: *mut PIXA, pixm: *mut PIX, debug: l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFractionMasked(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixm: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindWidthHeightRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixaFindWidthHeightProduct(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindOverlapFraction(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x2: l_int32,
        y2: l_int32,
        tab: *mut l_int32,
        pratio: *mut l_float32,
        pnoverlap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleComps(
        pixs: *mut PIX,
        dist: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConformsToRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pconforms: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipRectangles(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixClipRectangle(pixs: *mut PIX, box_: *mut BOX, pboxc: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixClipRectangleWithBorder(
        pixs: *mut PIX,
        box_: *mut BOX,
        maxbord: l_int32,
        pboxn: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixClipMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        outval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCropToMatch(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        ppixd1: *mut *mut PIX,
        ppixd2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropToSize(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeToMatch(pixs: *mut PIX, pixt: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFilterComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeSymmetricMask(
        w: l_int32,
        h: l_int32,
        hf: l_float32,
        vf: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeFrameMask(
        w: l_int32,
        h: l_int32,
        hf1: l_float32,
        hf2: l_float32,
        vf1: l_float32,
        vf2: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeCoveringOfRectangles(pixs: *mut PIX, maxiters: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFractionFgInMask(pix1: *mut PIX, pix2: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixClipToForeground(pixs: *mut PIX, ppixd: *mut *mut PIX, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixTestClipToForeground(pixs: *mut PIX, pcanclip: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToForeground(
        pixs: *mut PIX,
        boxs: *mut BOX,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForForeground(
        pixs: *mut PIX,
        box_: *mut BOX,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToEdges(
        pixs: *mut PIX,
        boxs: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForEdge(
        pixs: *mut PIX,
        box_: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExtractOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> l_float32;
}
extern "C" {
    pub fn pixAverageIntensityProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixReversalProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        minreversal: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixWindowedVarianceOnLine(
        pixs: *mut PIX,
        dir: l_int32,
        loc: l_int32,
        c1: l_int32,
        c2: l_int32,
        size: l_int32,
        pnad: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMinMaxNearLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        dist: l_int32,
        direction: l_int32,
        pnamin: *mut *mut NUMA,
        pnamax: *mut *mut NUMA,
        pminave: *mut l_float32,
        pmaxave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRankRowTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRankColumnTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixaCreate(n: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromPix(
        pixs: *mut PIX,
        n: l_int32,
        cellw: l_int32,
        cellh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromBoxa(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        start: l_int32,
        num: l_int32,
        pcropwarn: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitPix(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaDestroy(ppixa: *mut *mut PIXA);
}
extern "C" {
    pub fn pixaCopy(pixa: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPix(pixa: *mut PIXA, pix: *mut PIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAddBox(pixa: *mut PIXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaExtendArrayToSize(pixa: *mut PIXA, size: usize) -> l_ok;
}
extern "C" {
    pub fn pixaGetCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetPix(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetPixDimensions(
        pixa: *mut PIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetBoxa(pixa: *mut PIXA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaGetBoxaCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetBox(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixaGetBoxGeometry(
        pixa: *mut PIXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetBoxa(pixa: *mut PIXA, boxa: *mut BOXA, accesstype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPixArray(pixa: *mut PIXA) -> *mut *mut PIX;
}
extern "C" {
    pub fn pixaVerifyDepth(pixa: *mut PIXA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaVerifyDimensions(
        pixa: *mut PIXA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaIsFull(pixa: *mut PIXA, pfullpa: *mut l_int32, pfullba: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCountText(pixa: *mut PIXA, pntext: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaSetText(
        pixa: *mut PIXA,
        text: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetLinePtrs(
        pixa: *mut PIXA,
        psize: *mut l_int32,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixaWriteStreamInfo(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReplacePix(pixa: *mut PIXA, index: l_int32, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaInsertPix(pixa: *mut PIXA, index: l_int32, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePix(pixa: *mut PIXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePixAndSave(
        pixa: *mut PIXA,
        index: l_int32,
        ppix: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveSelected(pixa: *mut PIXA, naindex: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaInitFull(pixa: *mut PIXA, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaClear(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaJoin(pixad: *mut PIXA, pixas: *mut PIXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaInterleave(pixa1: *mut PIXA, pixa2: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaJoin(paad: *mut PIXAA, paas: *mut PIXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaCreate(n: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaCreateFromPixa(
        pixa: *mut PIXA,
        n: l_int32,
        type_: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaDestroy(ppaa: *mut *mut PIXAA);
}
extern "C" {
    pub fn pixaaAddPixa(paa: *mut PIXAA, pixa: *mut PIXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaAddPix(
        paa: *mut PIXAA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaAddBox(paa: *mut PIXAA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaGetCount(paa: *mut PIXAA, pna: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaaGetPixa(paa: *mut PIXAA, index: l_int32, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaGetBoxa(paa: *mut PIXAA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaaGetPix(
        paa: *mut PIXAA,
        index: l_int32,
        ipix: l_int32,
        accessflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaVerifyDepth(paa: *mut PIXAA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaVerifyDimensions(
        paa: *mut PIXAA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaIsFull(paa: *mut PIXAA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaInitFull(paa: *mut PIXAA, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaReplacePixa(paa: *mut PIXAA, index: l_int32, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaClear(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaTruncate(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadStream(fp: *mut FILE) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadMem(data: *const l_uint8, size: usize) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteDebug(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWrite(filename: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStream(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReadBoth(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadStream(fp: *mut FILE) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadMem(data: *const l_uint8, size: usize) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaWrite(filename: *const ::std::os::raw::c_char, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteStream(fp: *mut FILE, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaccCreate(w: l_int32, h: l_int32, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccCreateFromPix(pix: *mut PIX, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccDestroy(ppixacc: *mut *mut PIXACC);
}
extern "C" {
    pub fn pixaccFinal(pixacc: *mut PIXACC, outdepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetPix(pixacc: *mut PIXACC) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetOffset(pixacc: *mut PIXACC) -> l_int32;
}
extern "C" {
    pub fn pixaccAdd(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccSubtract(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConst(pixacc: *mut PIXACC, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConstAccumulate(pixacc: *mut PIXACC, pix: *mut PIX, factor: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixSelectBySize(
        pixs: *mut PIX,
        width: l_int32,
        height: l_int32,
        connectivity: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectBySize(
        pixas: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeSizeIndicator(
        pixa: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSelectByPerimToAreaRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimToAreaRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByPerimSizeRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimSizeRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByAreaFraction(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByAreaFraction(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByArea(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByArea(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByWidthHeightRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByWidthHeightRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectByNumConnComp(
        pixas: *mut PIXA,
        nmin: l_int32,
        nmax: l_int32,
        connectivity: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectWithIndicator(
        pixas: *mut PIXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixRemoveWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixAddWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaSelectWithString(
        pixas: *mut PIXA,
        str_: *const ::std::os::raw::c_char,
        perror: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRenderComponent(pixs: *mut PIX, pixa: *mut PIXA, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaBinSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSortByIndex(pixas: *mut PIXA, naindex: *mut NUMA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSort2dByIndex(pixas: *mut PIXA, naa: *mut NUMAA, copyflag: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaSelectRange(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSelectRange(
        paas: *mut PIXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSize(paas: *mut PIXAA, wd: l_int32, hd: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSizeVar(paas: *mut PIXAA, nawd: *mut NUMA, nahd: *mut NUMA) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaScaleToSize(pixas: *mut PIXA, wd: l_int32, hd: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleToSizeRel(pixas: *mut PIXA, delw: l_int32, delh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScale(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleBySampling(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32)
        -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotate(
        pixas: *mut PIXA,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotateOrth(pixas: *mut PIXA, rotation: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaTranslate(
        pixas: *mut PIXA,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddBorderGeneral(
        pixad: *mut PIXA,
        pixas: *mut PIXA,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaFlattenToPixa(
        paa: *mut PIXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSizeRange(
        paa: *mut PIXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSizeRange(
        pixa: *mut PIXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaClipToPix(pixas: *mut PIXA, pixs: *mut PIX) -> *mut PIXA;
}
extern "C" {
    pub fn pixaClipToForeground(
        pixas: *mut PIXA,
        ppixad: *mut *mut PIXA,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetRenderingDepth(pixa: *mut PIXA, pdepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaHasColor(pixa: *mut PIXA, phascolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAnyColormaps(pixa: *mut PIXA, phascmap: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetDepthInfo(pixa: *mut PIXA, pmaxdepth: *mut l_int32, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToSameDepth(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToGivenDepth(pixas: *mut PIXA, depth: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaEqual(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetFullSizeBoxa(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaDisplay(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayRandomCmap(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayLinearly(
        pixas: *mut PIXA,
        direction: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnLattice(
        pixa: *mut PIXA,
        cellw: l_int32,
        cellh: l_int32,
        pncols: *mut l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayUnsplit(
        pixa: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiled(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        background: l_int32,
        spacing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInRows(
        pixa: *mut PIXA,
        outdepth: l_int32,
        maxwidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInColumns(
        pixas: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledAndScaled(
        pixa: *mut PIXA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledWithText(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledByIndex(
        pixa: *mut PIXA,
        na: *mut NUMA,
        width: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayPairTiledInColumns(
        pixas1: *mut PIXA,
        pixas2: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing1: l_int32,
        spacing2: l_int32,
        border1: l_int32,
        border2: l_int32,
        fontsize: l_int32,
        startindex: l_int32,
        sa: *mut SARRAY,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplay(paa: *mut PIXAA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayByPixa(
        paa: *mut PIXAA,
        maxnx: l_int32,
        scalefactor: l_float32,
        hspacing: l_int32,
        vspacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayTiledAndScaled(
        paa: *mut PIXAA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo1(pixas: *mut PIXA, thresh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8(pixas: *mut PIXA, cmapflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8Colormap(pixas: *mut PIXA, dither: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo32(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConstrainedSelect(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectToPdf(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        color: l_uint32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaMakeFromTiledPixa(
        pixas: *mut PIXA,
        w: l_int32,
        h: l_int32,
        nsamp: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeFromTiledPix(
        pixs: *mut PIX,
        w: l_int32,
        h: l_int32,
        start: l_int32,
        num: l_int32,
        boxa: *mut BOXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixGetTileCount(pix: *mut PIX, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaDisplayMultiTiled(
        pixas: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        maxw: l_int32,
        maxh: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitIntoFiles(
        pixas: *mut PIXA,
        nsplit: l_int32,
        scale: l_float32,
        outwidth: l_int32,
        write_pixa: l_int32,
        write_pix: l_int32,
        write_pdf: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpFiles(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpPixa(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToNUpPixa(
        pixas: *mut PIXA,
        sa: *mut SARRAY,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCompareInPdf(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsCreate(
        minsize: usize,
        smallest: usize,
        numalloc: *mut NUMA,
        logfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsDestroy();
}
extern "C" {
    pub fn pmsCustomAlloc(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsCustomDealloc(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pmsGetAlloc(nbytes: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsGetLevelForAlloc(nbytes: usize, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsGetLevelForDealloc(data: *mut ::std::os::raw::c_void, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsLogInfo();
}
extern "C" {
    pub fn pixAddConstantGray(pixs: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstantGray(pixs: *mut PIX, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAddGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtractGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyGray(pixs: *mut PIX, pixg: *mut PIX, norm: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToValue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        threshval: l_int32,
        setval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInitAccumulate(w: l_int32, h: l_int32, offset: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulate(pixs: *mut PIX, offset: l_uint32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulateThreshold(
        pixs: *mut PIX,
        offset: l_uint32,
        threshold: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAccumulate(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstAccumulate(pixs: *mut PIX, factor: l_float32, offset: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDifference(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRGB(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMinOrMax(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRange(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRangeRGB(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn linearScaleRGBVal(sval: l_uint32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn logScaleRGBVal(sval: l_uint32, tab: *mut l_float32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn makeLogBase2Tab() -> *mut l_float32;
}
extern "C" {
    pub fn getLogBase2(val: l_int32, logtab: *mut l_float32) -> l_float32;
}
extern "C" {
    pub fn pixcompCreateFromPix(pix: *mut PIX, comptype: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromString(data: *mut l_uint8, size: usize, copyflag: l_int32)
        -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompDestroy(ppixc: *mut *mut PIXC);
}
extern "C" {
    pub fn pixcompCopy(pixcs: *mut PIXC) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompGetDimensions(
        pixc: *mut PIXC,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompGetParameters(
        pixc: *mut PIXC,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
        pcomptype: *mut l_int32,
        pcmapflag: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompDetermineFormat(
        comptype: l_int32,
        d: l_int32,
        cmapflag: l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCreateFromPixcomp(pixc: *mut PIXC) -> *mut PIX;
}
extern "C" {
    pub fn pixacompCreate(n: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateWithInit(
        n: l_int32,
        offset: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromPixa(
        pixa: *mut PIXA,
        comptype: l_int32,
        accesstype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromSA(sa: *mut SARRAY, comptype: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompDestroy(ppixac: *mut *mut PIXAC);
}
extern "C" {
    pub fn pixacompAddPix(pixac: *mut PIXAC, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompAddPixcomp(pixac: *mut PIXAC, pixc: *mut PIXC, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePix(
        pixac: *mut PIXAC,
        index: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePixcomp(pixac: *mut PIXAC, index: l_int32, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixacompAddBox(pixac: *mut PIXAC, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompGetCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetPixcomp(pixac: *mut PIXAC, index: l_int32, copyflag: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixacompGetPix(pixac: *mut PIXAC, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixacompGetPixDimensions(
        pixac: *mut PIXAC,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetBoxa(pixac: *mut PIXAC, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixacompGetBoxaCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBox(pixac: *mut PIXAC, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixacompGetBoxGeometry(
        pixac: *mut PIXAC,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetOffset(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompSetOffset(pixac: *mut PIXAC, offset: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCreateFromPixacomp(pixac: *mut PIXAC, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixacompJoin(
        pixacd: *mut PIXAC,
        pixacs: *mut PIXAC,
        istart: l_int32,
        iend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompInterleave(pixac1: *mut PIXAC, pixac2: *mut PIXAC) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadStream(fp: *mut FILE) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadMem(data: *const l_uint8, size: usize) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompWrite(filename: *const ::std::os::raw::c_char, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStream(fp: *mut FILE, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, pixac: *mut PIXAC)
        -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdf(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdfData(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompFastConvertToPdfData(
        pixac: *mut PIXAC,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStreamInfo(
        fp: *mut FILE,
        pixac: *mut PIXAC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteStreamInfo(
        fp: *mut FILE,
        pixc: *mut PIXC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompDisplayTiledAndScaled(
        pixac: *mut PIXAC,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixacompWriteFiles(pixac: *mut PIXAC, subdir: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteFile(rootname: *const ::std::os::raw::c_char, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixThreshold8(
        pixs: *mut PIX,
        d: l_int32,
        nlevels: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormapGeneral(pixs: *mut PIX, type_: l_int32, ifnocmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormap(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddGrayColormap8(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixAddMinimalGrayColormap8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToLuminance(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayGeneral(
        pixs: *mut PIX,
        type_: l_int32,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGray(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayFast(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayMinMax(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGraySatBoost(pixs: *mut PIX, refval: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToBinaryArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_int32,
        relation: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap8(pixs: *mut PIX, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixColorizeGray(pixs: *mut PIX, color: l_uint32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToColormap(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertCmapTo1(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantizeIfFewColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        mingraycolors: l_int32,
        octlevel: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvert16To8(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToFalseColor(pixs: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnpackBinary(pixs: *mut PIX, depth: l_int32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To16(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint16,
        val1: l_uint16,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To32(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint32,
        val1: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8(pixd: *mut PIX, pixs: *mut PIX, val0: l_uint8, val1: l_uint8)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert2To8(
        pixs: *mut PIX,
        val0: l_uint8,
        val1: l_uint8,
        val2: l_uint8,
        val3: l_uint8,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert4To8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To16(pixs: *mut PIX, leftshift: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To4(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1Adaptive(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1(pixs: *mut PIX, threshold: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1BySampling(pixs: *mut PIX, factor: l_int32, threshold: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8BySampling(pixs: *mut PIX, factor: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Colormap(pixs: *mut PIX, dither: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32BySampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Or32(pixs: *mut PIX, copyflag: l_int32, warnflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert24To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To24(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To16(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To8(pixs: *mut PIX, type16: l_int32, type8: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveAlpha(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaTo1bpp(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertLossless(pixs: *mut PIX, d: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertForPSWrap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertColorToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setNeutralBoostVal(val: l_int32);
}
extern "C" {
    pub fn pixConnCompTransform(pixs: *mut PIX, connect: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompAreaTransform(pixs: *mut PIX, connect: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompIncrInit(
        pixs: *mut PIX,
        conn: l_int32,
        ppixd: *mut *mut PIX,
        pptaa: *mut *mut PTAA,
        pncc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnCompIncrAdd(
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pncc: *mut l_int32,
        x: l_float32,
        y: l_float32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetSortedNeighborValues(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        conn: l_int32,
        pneigh: *mut *mut l_int32,
        pnvals: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixLocToColorTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingCreate(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        w: l_int32,
        h: l_int32,
        xoverlap: l_int32,
        yoverlap: l_int32,
    ) -> *mut PIXTILING;
}
extern "C" {
    pub fn pixTilingDestroy(ppt: *mut *mut PIXTILING);
}
extern "C" {
    pub fn pixTilingGetCount(pt: *mut PIXTILING, pnx: *mut l_int32, pny: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetSize(pt: *mut PIXTILING, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetTile(pt: *mut PIXTILING, i: l_int32, j: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingNoStripOnPaint(pt: *mut PIXTILING) -> l_ok;
}
extern "C" {
    pub fn pixTilingPaintTile(
        pixd: *mut PIX,
        i: l_int32,
        j: l_int32,
        pixs: *mut PIX,
        pt: *mut PIXTILING,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPng(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPng(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPng(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemPng(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn isPngInterlaced(
        filename: *const ::std::os::raw::c_char,
        pinterlaced: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngColormapInfo(
        fp: *mut FILE,
        pcmap: *mut *mut PIXCMAP,
        ptransparency: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePng(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPng(fp: *mut FILE, pix: *mut PIX, gamma: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetZlibCompression(pix: *mut PIX, compval: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_pngSetReadStrip16To8(flag: l_int32);
}
extern "C" {
    pub fn pixReadMemPng(filedata: *const l_uint8, filesize: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemPng(
        pfiledata: *mut *mut l_uint8,
        pfilesize: *mut usize,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPnm(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPnm(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPnm(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamAsciiPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPam(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemPnm(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemPnm(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPnm(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPam(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixProjectiveSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjective(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getProjectiveXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesToPS(
        sa: *mut SARRAY,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesFittedToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesFittedToPS(
        sa: *mut SARRAY,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageCompressedToPSFile(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedPagesToPS(
        pagedir: *const ::std::os::raw::c_char,
        pagestr: *const ::std::os::raw::c_char,
        page_numpre: l_int32,
        maskdir: *const ::std::os::raw::c_char,
        maskstr: *const ::std::os::raw::c_char,
        mask_numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteSegmentedPageToPS(
        pixs: *mut PIX,
        pixm: *mut PIX,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMixedToPS(
        pixb: *mut PIX,
        pixc: *mut PIX,
        scale: l_float32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteCompressedToPS(
        pixa: *mut PIXA,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteCompressedToPS(
        pix: *mut PIX,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPS(
        fp: *mut FILE,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStringPS(
        pixs: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generateUncompressedPS(
        hexdata: *mut ::std::os::raw::c_char,
        w: l_int32,
        h: l_int32,
        d: l_int32,
        psbpl: l_int32,
        bps: l_int32,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        boxflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertJpegToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertJpegToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        fillfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPS(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn getResLetterPage(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn getResA4Page(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_psWriteBoundingBox(flag: l_int32);
}
extern "C" {
    pub fn ptaCreate(n: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaCreateFromNuma(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaDestroy(ppta: *mut *mut PTA);
}
extern "C" {
    pub fn ptaCopy(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCopyRange(ptas: *mut PTA, istart: l_int32, iend: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaClone(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEmpty(pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaAddPt(pta: *mut PTA, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaInsertPt(pta: *mut PTA, index: l_int32, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaRemovePt(pta: *mut PTA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaGetCount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaGetPt(pta: *mut PTA, index: l_int32, px: *mut l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetIPt(pta: *mut PTA, index: l_int32, px: *mut l_int32, py: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaSetPt(pta: *mut PTA, index: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetArrays(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn ptaRead(filename: *const ::std::os::raw::c_char) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadStream(fp: *mut FILE) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadMem(data: *const l_uint8, size: usize) -> *mut PTA;
}
extern "C" {
    pub fn ptaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaWrite(filename: *const ::std::os::raw::c_char, pta: *mut PTA, type_: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn ptaWriteStream(fp: *mut FILE, pta: *mut PTA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaCreate(n: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaDestroy(pptaa: *mut *mut PTAA);
}
extern "C" {
    pub fn ptaaAddPta(ptaa: *mut PTAA, pta: *mut PTA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaGetCount(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaGetPta(ptaa: *mut PTAA, index: l_int32, accessflag: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetPt(
        ptaa: *mut PTAA,
        ipta: l_int32,
        jpt: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaInitFull(ptaa: *mut PTAA, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaReplacePta(ptaa: *mut PTAA, index: l_int32, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaAddPt(ptaa: *mut PTAA, ipta: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaaTruncate(ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn ptaaRead(filename: *const ::std::os::raw::c_char) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadStream(fp: *mut FILE) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadMem(data: *const l_uint8, size: usize) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWrite(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteStream(fp: *mut FILE, ptaa: *mut PTAA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSubsample(ptas: *mut PTA, subfactor: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaJoin(ptad: *mut PTA, ptas: *mut PTA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaJoin(ptaad: *mut PTAA, ptaas: *mut PTAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaReverse(ptas: *mut PTA, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaTranspose(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCyclicPerm(ptas: *mut PTA, xs: l_int32, ys: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaSelectRange(ptas: *mut PTA, first: l_int32, last: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetBoundingRegion(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn ptaGetRange(
        pta: *mut PTA,
        pminx: *mut l_float32,
        pmaxx: *mut l_float32,
        pminy: *mut l_float32,
        pmaxy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetInsideBox(ptas: *mut PTA, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixFindCornerPixels(pixs: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaContainsPt(pta: *mut PTA, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaTestIntersection(pta1: *mut PTA, pta2: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaTransform(
        ptas: *mut PTA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaPtInsidePolygon(
        pta: *mut PTA,
        x: l_float32,
        y: l_float32,
        pinside: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_angleBetweenVectors(
        x1: l_float32,
        y1: l_float32,
        x2: l_float32,
        y2: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn ptaPolygonIsConvex(pta: *mut PTA, pisconvex: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetMinMax(
        pta: *mut PTA,
        pxmin: *mut l_float32,
        pymin: *mut l_float32,
        pxmax: *mut l_float32,
        pymax: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSelectByValue(
        ptas: *mut PTA,
        xth: l_float32,
        yth: l_float32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaCropToMask(ptas: *mut PTA, pixm: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetLinearLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuadraticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetCubicLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuarticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pe: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyLinearLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyQuadraticLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn applyLinearFit(a: l_float32, b: l_float32, x: l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn applyQuadraticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyCubicFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyQuarticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        e: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPlotAlongPta(
        pixs: *mut PIX,
        pta: *mut PTA,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetPixelsFromPix(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGenerateFromPta(pta: *mut PTA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn ptaGetBoundaryPixels(pixs: *mut PIX, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetBoundaryPixels(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaIndexLabeledPixels(pixs: *mut PIX, pncc: *mut l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetNeighborPixLocs(pixs: *mut PIX, x: l_int32, y: l_int32, conn: l_int32)
        -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta1(na: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta2(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToNuma(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixDisplayPta(pixd: *mut PIX, pixs: *mut PIX, pta: *mut PTA) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pta: *mut PTA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ptaReplicatePattern(
        ptas: *mut PTA,
        pixp: *mut PIX,
        ptap: *mut PTA,
        cx: l_int32,
        cy: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDisplayPtaa(pixs: *mut PIX, ptaa: *mut PTAA) -> *mut PIX;
}
extern "C" {
    pub fn ptaSort(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetSortIndex(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSortByIndex(ptas: *mut PTA, naindex: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaaSortByIndex(ptaas: *mut PTAA, naindex: *mut NUMA) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetRankValue(
        pta: *mut PTA,
        fract: l_float32,
        ptasort: *mut PTA,
        sorttype: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSort2d(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEqual(pta1: *mut PTA, pta2: *mut PTA, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_asetCreateFromPta(pta: *mut PTA) -> *mut L_ASET;
}
extern "C" {
    pub fn ptaRemoveDupsByAset(ptas: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromPta(pta: *mut PTA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn ptaRemoveDupsByHmap(
        ptas: *mut PTA,
        pptad: *mut *mut PTA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptraCreate(n: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraDestroy(ppa: *mut *mut L_PTRA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraAdd(pa: *mut L_PTRA, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn ptraInsert(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        shiftflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraRemove(
        pa: *mut L_PTRA,
        index: l_int32,
        flag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraRemoveLast(pa: *mut L_PTRA) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraReplace(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        freeflag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraSwap(pa: *mut L_PTRA, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraCompactArray(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraReverse(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraJoin(pa1: *mut L_PTRA, pa2: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraGetMaxIndex(pa: *mut L_PTRA, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetActualCount(pa: *mut L_PTRA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetPtrToItem(pa: *mut L_PTRA, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraaCreate(n: l_int32) -> *mut L_PTRAA;
}
extern "C" {
    pub fn ptraaDestroy(ppaa: *mut *mut L_PTRAA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraaGetSize(paa: *mut L_PTRAA, psize: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraaInsertPtra(paa: *mut L_PTRAA, index: l_int32, pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraaGetPtra(paa: *mut L_PTRAA, index: l_int32, accessflag: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraaFlattenToPtra(paa: *mut L_PTRAA) -> *mut L_PTRA;
}
extern "C" {
    pub fn pixQuadtreeMean(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        pfpixa: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixQuadtreeVariance(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pfpixa_v: *mut *mut FPIXA,
        pfpixa_rv: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixma: *mut PIX,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaQuadtreeRegions(w: l_int32, h: l_int32, nlevels: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn quadtreeGetParent(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeGetChildren(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval00: *mut l_float32,
        pval10: *mut l_float32,
        pval01: *mut l_float32,
        pval11: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeMaxLevels(w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaDisplayQuadtree(fpixa: *mut FPIXA, factor: l_int32, fontsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lqueueCreate(nalloc: l_int32) -> *mut L_QUEUE;
}
extern "C" {
    pub fn lqueueDestroy(plq: *mut *mut L_QUEUE, freeflag: l_int32);
}
extern "C" {
    pub fn lqueueAdd(lq: *mut L_QUEUE, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lqueueRemove(lq: *mut L_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lqueueGetCount(lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn lqueuePrint(fp: *mut FILE, lq: *mut L_QUEUE) -> l_ok;
}
extern "C" {
    pub fn pixRankFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterRGB(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterGray(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixMedianFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterWithScaling(
        pixs: *mut PIX,
        wf: l_int32,
        hf: l_int32,
        rank: l_float32,
        scalefactor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_rbtreeCreate(keytype: l_int32) -> *mut L_RBTREE;
}
extern "C" {
    pub fn l_rbtreeLookup(t: *mut L_RBTREE, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_rbtreeInsert(t: *mut L_RBTREE, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDelete(t: *mut L_RBTREE, key: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDestroy(pt: *mut *mut L_RBTREE);
}
extern "C" {
    pub fn l_rbtreeGetFirst(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetNext(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetLast(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetPrev(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetCount(t: *mut L_RBTREE) -> l_int32;
}
extern "C" {
    pub fn l_rbtreePrint(fp: *mut FILE, t: *mut L_RBTREE);
}
extern "C" {
    pub fn pixProcessBarcodes(
        pixs: *mut PIX,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixExtractBarcodes(pixs: *mut PIX, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixReadBarcodes(
        pixa: *mut PIXA,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadBarcodeWidths(pixs: *mut PIX, method: l_int32, debugflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixLocateBarcodes(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixb: *mut *mut PIX,
        ppixm: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixDeskewBarcode(
        pixs: *mut PIX,
        pixb: *mut PIX,
        box_: *mut BOX,
        margin: l_int32,
        threshold: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBarcodeWidths1(
        pixs: *mut PIX,
        thresh: l_float32,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeWidths2(
        pixs: *mut PIX,
        thresh: l_float32,
        pwidth: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeCrossings(
        pixs: *mut PIX,
        thresh: l_float32,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWidth(
        nas: *mut NUMA,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWindow(
        nas: *mut NUMA,
        ratio: l_float32,
        pwidth: *mut l_float32,
        pfirstloc: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaReadFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadFilesSA(sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn pixRead(filename: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn pixReadWithHint(filename: *const ::std::os::raw::c_char, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadIndexed(sa: *mut SARRAY, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStream(fp: *mut FILE, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeader(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findFileFormat(filename: *const ::std::os::raw::c_char, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatStream(fp: *mut FILE, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatBuffer(buf: *const l_uint8, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fileFormatIsTiff(fp: *mut FILE) -> l_int32;
}
extern "C" {
    pub fn pixReadMem(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeaderMem(
        data: *const l_uint8,
        size: usize,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageFileInfo(
        filename: *const ::std::os::raw::c_char,
        fpout: *mut FILE,
        headeronly: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ioFormatTest(filename: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn recogCreateFromRecog(
        recs: *mut L_RECOG,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixa(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixaNoFinish(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreate(
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogDestroy(precog: *mut *mut L_RECOG);
}
extern "C" {
    pub fn recogGetCount(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogSetParams(
        recog: *mut L_RECOG,
        type_: l_int32,
        min_nopad: l_int32,
        max_wh_ratio: l_float32,
        max_ht_ratio: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassIndex(
        recog: *mut L_RECOG,
        val: l_int32,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogStringToIndex(
        recog: *mut L_RECOG,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassString(
        recog: *mut L_RECOG,
        index: l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_convertCharstrToInt(str_: *const ::std::os::raw::c_char, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn recogRead(filename: *const ::std::os::raw::c_char) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadStream(fp: *mut FILE) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadMem(data: *const l_uint8, size: usize) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogWrite(filename: *const ::std::os::raw::c_char, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteStream(fp: *mut FILE, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogExtractPixa(recog: *mut L_RECOG) -> *mut PIXA;
}
extern "C" {
    pub fn recogDecode(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        nlevels: l_int32,
        ppixdb: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn recogCreateDid(recog: *mut L_RECOG, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogDestroyDid(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogDidExists(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogGetDid(recog: *mut L_RECOG) -> *mut L_RDID;
}
extern "C" {
    pub fn recogSetChannelParams(recog: *mut L_RECOG, nlevels: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyMultiple(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdb: *mut *mut PIX,
        debugsplit: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogSplitIntoCharacters(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestRow(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pboxa: *mut *mut BOXA,
        pnascore: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        psachar: *mut *mut SARRAY,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestChar(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pbox: *mut *mut BOX,
        pscore: *mut l_float32,
        pindex: *mut l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPixa(recog: *mut L_RECOG, pixa: *mut PIXA, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPix(recog: *mut L_RECOG, pixs: *mut PIX, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogSkipIdentify(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn rchaDestroy(prcha: *mut *mut L_RCHA);
}
extern "C" {
    pub fn rchDestroy(prch: *mut *mut L_RCH);
}
extern "C" {
    pub fn rchaExtract(
        rcha: *mut L_RCHA,
        pnaindex: *mut *mut NUMA,
        pnascore: *mut *mut NUMA,
        psatext: *mut *mut SARRAY,
        pnasample: *mut *mut NUMA,
        pnaxloc: *mut *mut NUMA,
        pnayloc: *mut *mut NUMA,
        pnawidth: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn rchExtract(
        rch: *mut L_RCH,
        pindex: *mut l_int32,
        pscore: *mut l_float32,
        ptext: *mut *mut ::std::os::raw::c_char,
        psample: *mut l_int32,
        pxloc: *mut l_int32,
        pyloc: *mut l_int32,
        pwidth: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessToIdentify(recog: *mut L_RECOG, pixs: *mut PIX, pad: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn recogExtractNumbers(
        recog: *mut L_RECOG,
        boxas: *mut BOXA,
        scorethresh: l_float32,
        spacethresh: l_int32,
        pbaa: *mut *mut BOXAA,
        pnaa: *mut *mut NUMAA,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn showExtractNumbers(
        pixs: *mut PIX,
        sa: *mut SARRAY,
        baa: *mut BOXAA,
        naa: *mut NUMAA,
        ppixdb: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        ppix: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogAddSample(recog: *mut L_RECOG, pix: *mut PIX, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogModifyTemplate(recog: *mut L_RECOG, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn recogAverageSamples(precog: *mut *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAccumulateSamples(
        pixa: *mut PIXA,
        pta: *mut PTA,
        ppixd: *mut *mut PIX,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogTrainingFinished(
        precog: *mut *mut L_RECOG,
        modifyflag: l_int32,
        minsize: l_int32,
        minfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogFilterPixaBySize(
        pixas: *mut PIXA,
        setsize: l_int32,
        maxkeep: l_int32,
        max_ht_ratio: l_float32,
        pna: *mut *mut NUMA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogSortPixaByClass(pixa: *mut PIXA, setsize: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn recogRemoveOutliers1(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers1(
        pixas: *mut PIXA,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogRemoveOutliers2(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers2(
        pixas: *mut PIXA,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainFromBoot(
        recogboot: *mut L_RECOG,
        pixas: *mut PIXA,
        minscore: l_float32,
        threshold: l_int32,
        debug: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogPadDigitTrainingSet(
        precog: *mut *mut L_RECOG,
        scaleh: l_int32,
        linew: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIsPaddingNeeded(recog: *mut L_RECOG, psa: *mut *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn recogAddDigitPadTemplates(recog: *mut L_RECOG, sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn recogMakeBootDigitRecog(
        nsamp: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        maxyshift: l_int32,
        debug: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogMakeBootDigitTemplates(nsamp: l_int32, debug: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn recogShowContent(
        fp: *mut FILE,
        recog: *mut L_RECOG,
        index: l_int32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogDebugAverages(precog: *mut *mut L_RECOG, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogShowAverageTemplates(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogShowMatchesInRange(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        minscore: l_float32,
        maxscore: l_float32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogShowMatch(
        recog: *mut L_RECOG,
        pix1: *mut PIX,
        pix2: *mut PIX,
        box_: *mut BOX,
        index: l_int32,
        score: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn regTestSetup(
        argc: l_int32,
        argv: *mut *mut ::std::os::raw::c_char,
        prp: *mut *mut L_REGPARAMS,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCleanup(rp: *mut L_REGPARAMS) -> l_ok;
}
extern "C" {
    pub fn regTestCompareValues(
        rp: *mut L_REGPARAMS,
        val1: l_float32,
        val2: l_float32,
        delta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCompareStrings(
        rp: *mut L_REGPARAMS,
        string1: *mut l_uint8,
        bytes1: usize,
        string2: *mut l_uint8,
        bytes2: usize,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestComparePix(rp: *mut L_REGPARAMS, pix1: *mut PIX, pix2: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn regTestCompareSimilarPix(
        rp: *mut L_REGPARAMS,
        pix1: *mut PIX,
        pix2: *mut PIX,
        mindiff: l_int32,
        maxfract: l_float32,
        printstats: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCheckFile(rp: *mut L_REGPARAMS, localname: *const ::std::os::raw::c_char)
        -> l_ok;
}
extern "C" {
    pub fn regTestCompareFiles(rp: *mut L_REGPARAMS, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWritePixAndCheck(rp: *mut L_REGPARAMS, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWriteDataAndCheck(
        rp: *mut L_REGPARAMS,
        data: *mut ::std::os::raw::c_void,
        nbytes: usize,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestGenLocalFilename(
        rp: *mut L_REGPARAMS,
        index: l_int32,
        format: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixRasterop(
        pixd: *mut PIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropVip(
        pixd: *mut PIX,
        bx: l_int32,
        bw: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropHip(
        pixd: *mut PIX,
        by: l_int32,
        bh: l_int32,
        hshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixTranslate(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRasteropIP(
        pixd: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropFullImage(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn rasteropUniLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
    );
}
extern "C" {
    pub fn rasteropLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        datas: *mut l_uint32,
        spixw: l_int32,
        spixh: l_int32,
        swpl: l_int32,
        sx: l_int32,
        sy: l_int32,
    );
}
extern "C" {
    pub fn rasteropVipLow(
        data: *mut l_uint32,
        pixw: l_int32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        x: l_int32,
        w: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn rasteropHipLow(
        data: *mut l_uint32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        y: l_int32,
        h: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn pixRotate(
        pixs: *mut PIX,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEmbedForRotation(
        pixs: *mut PIX,
        angle: l_float32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBySampling(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBinaryNice(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateWithAlpha(
        pixs: *mut PIX,
        angle: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAM(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColor(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGray(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMCorner(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorCorner(pixs: *mut PIX, angle: l_float32, fillval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGrayCorner(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorFast(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateOrth(pixs: *mut PIX, quads: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate180(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate90(pixs: *mut PIX, direction: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipLR(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipTB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate2Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate3Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearIP(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRotateShearCenter(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearCenterIP(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixStrokeWidthTransform(
        pixs: *mut PIX,
        color: l_int32,
        depth: l_int32,
        nangles: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunlengthTransform(
        pixs: *mut PIX,
        color: l_int32,
        direction: l_int32,
        depth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHorizontalRuns(
        pix: *mut PIX,
        y: l_int32,
        xstart: *mut l_int32,
        xend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindVerticalRuns(
        pix: *mut PIX,
        x: l_int32,
        ystart: *mut l_int32,
        yend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxRuns(pix: *mut PIX, direction: l_int32, pnastart: *mut *mut NUMA)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindMaxHorizontalRunOnLine(
        pix: *mut PIX,
        y: l_int32,
        pxstart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxVerticalRunOnLine(
        pix: *mut PIX,
        x: l_int32,
        pystart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn runlengthMembershipOnLine(
        buffer: *mut l_int32,
        size: l_int32,
        depth: l_int32,
        start: *mut l_int32,
        end: *mut l_int32,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeMSBitLocTab(bitval: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn sarrayCreate(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateInitialized(
        n: l_int32,
        initstr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateWordsFromString(string: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateLinesFromString(
        string: *const ::std::os::raw::c_char,
        blankflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayDestroy(psa: *mut *mut SARRAY);
}
extern "C" {
    pub fn sarrayCopy(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayClone(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayAddString(
        sa: *mut SARRAY,
        string: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayRemoveString(sa: *mut SARRAY, index: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayReplaceString(
        sa: *mut SARRAY,
        index: l_int32,
        newstr: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayClear(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayGetCount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetArray(
        sa: *mut SARRAY,
        pnalloc: *mut l_int32,
        pn: *mut l_int32,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetString(
        sa: *mut SARRAY,
        index: l_int32,
        copyflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToString(sa: *mut SARRAY, addnlflag: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToStringRange(
        sa: *mut SARRAY,
        first: l_int32,
        nstrings: l_int32,
        addnlflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayConcatUniformly(sa: *mut SARRAY, n: l_int32, addnlflag: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayJoin(sa1: *mut SARRAY, sa2: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppendRange(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        start: l_int32,
        end: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayPadToSameSize(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        padstring: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertWordsToLines(sa: *mut SARRAY, linesize: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySplitString(
        sa: *mut SARRAY,
        str_: *const ::std::os::raw::c_char,
        separators: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarraySelectBySubstring(
        sain: *mut SARRAY,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySelectRange(sain: *mut SARRAY, first: l_int32, last: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayParseRange(
        sa: *mut SARRAY,
        start: l_int32,
        pactualstart: *mut l_int32,
        pend: *mut l_int32,
        pnewstart: *mut l_int32,
        substr: *const ::std::os::raw::c_char,
        loc: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRead(filename: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadStream(fp: *mut FILE) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadMem(data: *const l_uint8, size: usize) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayWrite(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStream(fp: *mut FILE, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStderr(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteMem(pdata: *mut *mut l_uint8, psize: *mut usize, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppend(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn getNumberedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getSortedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn convertSortedToNumberedPathnames(
        sa: *mut SARRAY,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getFilenamesInDirectory(dirname: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySort(saout: *mut SARRAY, sain: *mut SARRAY, sortorder: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySortByIndex(sain: *mut SARRAY, naindex: *mut NUMA) -> *mut SARRAY;
}
extern "C" {
    pub fn stringCompareLexical(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_asetCreateFromSarray(sa: *mut SARRAY) -> *mut L_ASET;
}
extern "C" {
    pub fn sarrayRemoveDupsByAset(sas: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByAset(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromSarray(sa: *mut SARRAY) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn sarrayRemoveDupsByHmap(
        sas: *mut SARRAY,
        psad: *mut *mut SARRAY,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByHmap(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByHmap(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayGenerateIntegers(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayLookupCSKV(
        sa: *mut SARRAY,
        keystring: *const ::std::os::raw::c_char,
        pvalstring: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScale(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSizeRel(pixs: *mut PIX, delw: l_int32, delh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToResolution(
        pixs: *mut PIX,
        target: l_float32,
        assumed: l_float32,
        pscalefact: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGeneral(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        sharpfract: l_float32,
        sharpwidth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColorLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySampling(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySamplingToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleByIntSampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGrayFast(pixs: *mut PIX, factor: l_int32, color: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmooth(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmoothToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGray2(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMapToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBinary(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayFast(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray3(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray6(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayMipmap(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleMipmap(pixs1: *mut PIX, pixs2: *mut PIX, scale: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandReplicate(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax(
        pixs: *mut PIX,
        xfact: l_int32,
        yfact: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax2(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRankCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRank2(pixs: *mut PIX, rank: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScaleWithAlpha(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinary(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinaryRestricted(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        xmax: l_int32,
        ymax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHolesByFilling(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillClosedBorders(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillBgFromBorder(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillHolesToBoundingRect(
        pixs: *mut PIX,
        minsize: l_int32,
        maxhfract: l_float32,
        minfgfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillGray(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInv(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGraySimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInvSimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayBasin(
        pixb: *mut PIX,
        pixm: *mut PIX,
        delta: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDistanceFunction(
        pixs: *mut PIX,
        connectivity: l_int32,
        outdepth: l_int32,
        boundcond: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedspread(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixLocalExtrema(
        pixs: *mut PIX,
        maxmin: l_int32,
        minmax: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectedLocalExtrema(
        pixs: *mut PIX,
        mindist: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindEqualValues(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectMinInConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        ppta: *mut *mut PTA,
        pnav: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRemoveSeededComponents(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        bordersize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaCreate(n: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn selaDestroy(psela: *mut *mut SELA);
}
extern "C" {
    pub fn selCreate(
        height: l_int32,
        width: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selDestroy(psel: *mut *mut SEL);
}
extern "C" {
    pub fn selCopy(sel: *mut SEL) -> *mut SEL;
}
extern "C" {
    pub fn selCreateBrick(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        type_: l_int32,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateComb(factor1: l_int32, factor2: l_int32, direction: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn create2dIntArray(sy: l_int32, sx: l_int32) -> *mut *mut l_int32;
}
extern "C" {
    pub fn selaAddSel(
        sela: *mut SELA,
        sel: *mut SEL,
        selname: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetCount(sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaGetSel(sela: *mut SELA, i: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selGetName(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selSetName(sel: *mut SEL, name: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn selaFindSelByName(
        sela: *mut SELA,
        name: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
        psel: *mut *mut SEL,
    ) -> l_ok;
}
extern "C" {
    pub fn selGetElement(sel: *mut SEL, row: l_int32, col: l_int32, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selSetElement(sel: *mut SEL, row: l_int32, col: l_int32, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetParameters(
        sel: *mut SEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selSetOrigin(sel: *mut SEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetTypeAtOrigin(sel: *mut SEL, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selaGetBrickName(
        sela: *mut SELA,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaGetCombName(
        sela: *mut SELA,
        size: l_int32,
        direction: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getCompositeParameters(
        size: l_int32,
        psize1: *mut l_int32,
        psize2: *mut l_int32,
        pnameh1: *mut *mut ::std::os::raw::c_char,
        pnameh2: *mut *mut ::std::os::raw::c_char,
        pnamev1: *mut *mut ::std::os::raw::c_char,
        pnamev2: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetSelnames(sela: *mut SELA) -> *mut SARRAY;
}
extern "C" {
    pub fn selFindMaxTranslations(
        sel: *mut SEL,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
        pxn: *mut l_int32,
        pyn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selRotateOrth(sel: *mut SEL, quads: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selaRead(fname: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selaReadStream(fp: *mut FILE) -> *mut SELA;
}
extern "C" {
    pub fn selRead(fname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selReadStream(fp: *mut FILE) -> *mut SEL;
}
extern "C" {
    pub fn selaWrite(fname: *const ::std::os::raw::c_char, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selaWriteStream(fp: *mut FILE, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selWrite(fname: *const ::std::os::raw::c_char, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selWriteStream(fp: *mut FILE, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selCreateFromString(
        text: *const ::std::os::raw::c_char,
        h: l_int32,
        w: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selPrintToString(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selCreateFromPta(
        pta: *mut PTA,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromPix(
        pix: *mut PIX,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selReadFromColorImage(pathname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromColorPix(
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selaCreateFromColorPixa(pixa: *mut PIXA, sa: *mut SARRAY) -> *mut SELA;
}
extern "C" {
    pub fn selDisplayInPix(sel: *mut SEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn selaDisplayInPix(
        sela: *mut SELA,
        size: l_int32,
        gthick: l_int32,
        spacing: l_int32,
        ncols: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaAddBasic(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddHitMiss(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaLinear(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaCombs(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddCrossJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn selaAddTJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn sela4ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela4and8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selMakePlusSign(size: l_int32, linewidth: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelWithRuns(
        pixs: *mut PIX,
        nhlines: l_int32,
        nvlines: l_int32,
        distance: l_int32,
        minlength: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelRandom(
        pixs: *mut PIX,
        hitfract: l_float32,
        missfract: l_float32,
        distance: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelBoundary(
        pixs: *mut PIX,
        hitdist: l_int32,
        missdist: l_int32,
        hitskip: l_int32,
        missskip: l_int32,
        topflag: l_int32,
        botflag: l_int32,
        leftflag: l_int32,
        rightflag: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGetRunCentersOnLine(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        minlength: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRunsOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSubsampleBoundaryPixels(pixs: *mut PIX, skip: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn adjacentOnPixelInRaster(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        pxa: *mut l_int32,
        pya: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayHitMissSel(
        pixs: *mut PIX,
        sel: *mut SEL,
        scalefactor: l_int32,
        hitcolor: l_uint32,
        misscolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearIP(pixs: *mut PIX, yloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixVShearIP(pixs: *mut PIX, xloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixHShearLI(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearLI(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewBoth(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskew(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkewAndDeskew(
        pixs: *mut PIX,
        redsearch: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewGeneral(
        pixs: *mut PIX,
        redsweep: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        redsearch: l_int32,
        thresh: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkew(pixs: *mut PIX, pangle: *mut l_float32, pconf: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweep(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        reduction: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearch(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScore(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScorePivot(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pivot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewOrthogonalRange(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        confprior: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindDifferentialSquareSum(pixs: *mut PIX, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindNormalizedSquareSum(
        pixs: *mut PIX,
        phratio: *mut l_float32,
        pvratio: *mut l_float32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamSpix(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderSpix(
        filename: *const ::std::os::raw::c_char,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderSpix(
        fp: *mut FILE,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sreadHeaderSpix(
        data: *const l_uint32,
        size: usize,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamSpix(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemSpix(data: *const l_uint8, size: usize) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemSpix(pdata: *mut *mut l_uint8, psize: *mut usize, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSerializeToMemory(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint32,
        pnbytes: *mut usize,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDeserializeFromMemory(data: *const l_uint32, nbytes: usize) -> *mut PIX;
}
extern "C" {
    pub fn lstackCreate(n: l_int32) -> *mut L_STACK;
}
extern "C" {
    pub fn lstackDestroy(plstack: *mut *mut L_STACK, freeflag: l_int32);
}
extern "C" {
    pub fn lstackAdd(lstack: *mut L_STACK, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lstackRemove(lstack: *mut L_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lstackGetCount(lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn lstackPrint(fp: *mut FILE, lstack: *mut L_STACK) -> l_ok;
}
extern "C" {
    pub fn strcodeCreate(fileno: l_int32) -> *mut L_STRCODE;
}
extern "C" {
    pub fn strcodeCreateFromFile(
        filein: *const ::std::os::raw::c_char,
        fileno: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeGenerate(
        strcode: *mut L_STRCODE,
        filein: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeFinalize(
        pstrcode: *mut *mut L_STRCODE,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getStructStrFromFile(
        filename: *const ::std::os::raw::c_char,
        field: l_int32,
        pstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeLength(pixs: *mut PIX, tab8: *mut l_int32, plength: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFindStrokeWidth(
        pixs: *mut PIX,
        thresh: l_float32,
        tab8: *mut l_int32,
        pwidth: *mut l_float32,
        pnahisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindStrokeWidth(
        pixa: *mut PIXA,
        thresh: l_float32,
        tab8: *mut l_int32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaModifyStrokeWidth(pixas: *mut PIXA, targetw: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixModifyStrokeWidth(pixs: *mut PIX, width: l_float32, targetw: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSetStrokeWidth(
        pixas: *mut PIXA,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSetStrokeWidth(
        pixs: *mut PIX,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn sudokuReadFile(filename: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuReadString(str_: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuCreate(array: *mut l_int32) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuDestroy(psud: *mut *mut L_SUDOKU);
}
extern "C" {
    pub fn sudokuSolve(sud: *mut L_SUDOKU) -> l_int32;
}
extern "C" {
    pub fn sudokuTestUniqueness(array: *mut l_int32, punique: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn sudokuGenerate(
        array: *mut l_int32,
        seed: l_int32,
        minelems: l_int32,
        maxtries: l_int32,
    ) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuOutput(sud: *mut L_SUDOKU, arraytype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAddSingleTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
        poverflow: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddTextlines(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        wtext: l_int32,
        firstindent: l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetTextline(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        pwidth: *mut l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaAddTextNumber(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        na: *mut NUMA,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddTextlines(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        sa: *mut SARRAY,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPixWithText(
        pixa: *mut PIXA,
        pixs: *mut PIX,
        reduction: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfGetLineStrings(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        maxw: l_int32,
        firstindent: l_int32,
        ph: *mut l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn bmfGetWordWidths(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bmfGetStringWidth(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn splitStringToParagraphs(
        textstr: *mut ::std::os::raw::c_char,
        splitflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadTiff(filename: *const ::std::os::raw::c_char, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamTiff(fp: *mut FILE, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteTiff(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteTiffCustom(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiff(fp: *mut FILE, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiffWA(
        fp: *mut FILE,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadFromMultipageTiff(
        fname: *const ::std::os::raw::c_char,
        poffset: *mut usize,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMultipageTiff(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMultipageTiff(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiff(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiffSA(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn fprintTiffInfo(fpout: *mut FILE, tiffile: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn tiffGetCount(fp: *mut FILE, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getTiffResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn readHeaderTiff(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderTiff(
        fp: *mut FILE,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemTiff(
        cdata: *const l_uint8,
        size: usize,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findTiffCompression(fp: *mut FILE, pcomptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn extractG4DataFromFile(
        filein: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pminisblack: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemTiff(cdata: *const l_uint8, size: usize, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemFromMultipageTiff(
        cdata: *const l_uint8,
        size: usize,
        poffset: *mut usize,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMemMultipageTiff(data: *const l_uint8, size: usize) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMemMultipageTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pixa: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiffCustom(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        comptype: l_int32,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn setMsgSeverity(newsev: l_int32) -> l_int32;
}
extern "C" {
    pub fn returnErrorInt(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        ival: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn returnErrorFloat(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        fval: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn returnErrorPtr(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        pval: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn leptSetStderrHandler(
        handler: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn lept_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn filesAreIdentical(
        fname1: *const ::std::os::raw::c_char,
        fname2: *const ::std::os::raw::c_char,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertOnLittleEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnBigEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnLittleEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertOnBigEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn fileCorruptByDeletion(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCorruptByMutation(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileReplaceBytes(
        filein: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
        newdata: *mut l_uint8,
        newsize: usize,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn genRandomIntOnInterval(
        start: l_int32,
        end: l_int32,
        seed: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn lept_roundftoi(fval: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_hashStringToUint64(str_: *const ::std::os::raw::c_char, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashStringToUint64Fast(
        str_: *const ::std::os::raw::c_char,
        phash: *mut l_uint64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hashPtToUint64(x: l_int32, y: l_int32, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashFloat64ToUint64(val: l_float64, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn findNextLargerPrime(start: l_int32, pprime: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn lept_isPrime(n: l_uint64, pis_prime: *mut l_int32, pfactor: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn convertIntToGrayCode(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertGrayCodeToInt(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn getLeptonicaVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn startTimer();
}
extern "C" {
    pub fn stopTimer() -> l_float32;
}
extern "C" {
    pub fn startTimerNested() -> L_TIMER;
}
extern "C" {
    pub fn stopTimerNested(rusage_start: L_TIMER) -> l_float32;
}
extern "C" {
    pub fn l_getCurrentTime(sec: *mut l_int32, usec: *mut l_int32);
}
extern "C" {
    pub fn startWallTimer() -> *mut L_WALLTIMER;
}
extern "C" {
    pub fn stopWallTimer(ptimer: *mut *mut L_WALLTIMER) -> l_float32;
}
extern "C" {
    pub fn l_getFormattedDate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringNew(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringCopy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCopySegment(
        src: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplace(
        pdest: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringLength(src: *const ::std::os::raw::c_char, size: usize) -> l_int32;
}
extern "C" {
    pub fn stringCat(
        dest: *mut ::std::os::raw::c_char,
        size: usize,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringConcatNew(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoin(
        src1: *const ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoinIP(
        psrc1: *mut *mut ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringReverse(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtokSafe(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        psaveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringSplitOnToken(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        phead: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCheckForChars(
        src: *const ::std::os::raw::c_char,
        chars: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringRemoveChars(
        src: *const ::std::os::raw::c_char,
        remchars: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pcount: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
        pfound: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringFindEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn stringFindSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn arrayReplaceEachSequence(
        datas: *const l_uint8,
        dataslen: usize,
        seq: *const l_uint8,
        seqlen: usize,
        newseq: *const l_uint8,
        newseqlen: usize,
        pdatadlen: *mut usize,
        pcount: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn arrayFindEachSequence(
        data: *const l_uint8,
        datalen: usize,
        sequence: *const l_uint8,
        seqlen: usize,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn arrayFindSequence(
        data: *const l_uint8,
        datalen: usize,
        sequence: *const l_uint8,
        seqlen: usize,
        poffset: *mut l_int32,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn reallocNew(
        pindata: *mut *mut ::std::os::raw::c_void,
        oldsize: usize,
        newsize: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn l_binaryRead(
        filename: *const ::std::os::raw::c_char,
        pnbytes: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadStream(fp: *mut FILE, pnbytes: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelect(
        filename: *const ::std::os::raw::c_char,
        start: usize,
        nbytes: usize,
        pnread: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelectStream(
        fp: *mut FILE,
        start: usize,
        nbytes: usize,
        pnread: *mut usize,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryWrite(
        filename: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        nbytes: usize,
    ) -> l_ok;
}
extern "C" {
    pub fn nbytesInFile(filename: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn fnbytesInFile(fp: *mut FILE) -> usize;
}
extern "C" {
    pub fn l_binaryCopy(datas: *const l_uint8, size: usize) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryCompare(
        data1: *const l_uint8,
        size1: usize,
        data2: *const l_uint8,
        size2: usize,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCopy(
        srcfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileConcatenate(
        srcfile: *const ::std::os::raw::c_char,
        destfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileAppendString(
        filename: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileSplitLinesUniform(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        save_empty: l_int32,
        rootpath: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fopenReadStream(filename: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteStream(
        filename: *const ::std::os::raw::c_char,
        modestring: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopenReadFromMemory(data: *const l_uint8, size: usize) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteWinTempfile() -> *mut FILE;
}
extern "C" {
    pub fn lept_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn lept_fclose(fp: *mut FILE) -> l_ok;
}
extern "C" {
    pub fn lept_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lept_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lept_mkdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_rmdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_direxists(dir: *const ::std::os::raw::c_char, pexists: *mut l_int32);
}
extern "C" {
    pub fn lept_rm_match(
        subdir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rm(
        subdir: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rmfile(filepath: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_mv(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_cp(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn callSystemDebug(cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn splitPathAtDirectory(
        pathname: *const ::std::os::raw::c_char,
        pdir: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn splitPathAtExtension(
        pathname: *const ::std::os::raw::c_char,
        pbasename: *mut *mut ::std::os::raw::c_char,
        pextension: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pathJoin(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn appendSubdirs(
        basedir: *const ::std::os::raw::c_char,
        subdirs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertSepCharsInPath(path: *mut ::std::os::raw::c_char, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn genPathname(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn makeTempDirname(
        result: *mut ::std::os::raw::c_char,
        nbytes: usize,
        subdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn modifyTrailingSlash(
        path: *mut ::std::os::raw::c_char,
        nbytes: usize,
        flag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_makeTempFilename() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn extractNumberFromFilename(
        fname: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleCaptcha(
        pixs: *mut PIX,
        border: l_int32,
        nterms: l_int32,
        seed: l_uint32,
        color: l_uint32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRandomHarmonicWarp(
        pixs: *mut PIX,
        xmag: l_float32,
        ymag: l_float32,
        xfreq: l_float32,
        yfreq: l_float32,
        nx: l_int32,
        ny: l_int32,
        seed: l_uint32,
        grayval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWarpStereoscopic(
        pixs: *mut PIX,
        zbend: l_int32,
        zshiftt: l_int32,
        zshiftb: l_int32,
        ybendt: l_int32,
        ybendb: l_int32,
        redleft: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontal(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalSampled(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalLI(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShear(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearSampled(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearLI(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStereoFromPair(
        pix1: *mut PIX,
        pix2: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn wshedCreate(
        pixs: *mut PIX,
        pixm: *mut PIX,
        mindepth: l_int32,
        debugflag: l_int32,
    ) -> *mut L_WSHED;
}
extern "C" {
    pub fn wshedDestroy(pwshed: *mut *mut L_WSHED);
}
extern "C" {
    pub fn wshedApply(wshed: *mut L_WSHED) -> l_ok;
}
extern "C" {
    pub fn wshedBasins(
        wshed: *mut L_WSHED,
        ppixa: *mut *mut PIXA,
        pnalevels: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn wshedRenderFill(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn wshedRenderColors(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn pixaWriteWebPAnim(
        filename: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStreamWebPAnim(
        fp: *mut FILE,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMemWebPAnim(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut usize,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamWebP(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemWebP(filedata: *const l_uint8, filesize: usize) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderWebP(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemWebP(
        data: *const l_uint8,
        size: usize,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteWebP(
        filename: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamWebP(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemWebP(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut usize,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_jpegSetQuality(new_quality: l_int32) -> l_int32;
}
extern "C" {
    pub fn setLeptDebugOK(allow: l_int32);
}
extern "C" {
    pub fn pixaWriteFiles(
        rootname: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteDebug(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWrite(fname: *const ::std::os::raw::c_char, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteAutoFormat(filename: *const ::std::os::raw::c_char, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStream(fp: *mut FILE, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteImpliedFormat(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixChooseOutputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn getImpliedFileFormat(filename: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixGetAutoFormat(pix: *mut PIX, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getFormatExtension(format: l_int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut usize,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_fileDisplay(
        fname: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplay(pixs: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayWithTitle(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        title: *const ::std::os::raw::c_char,
        dispflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeColorSquare(
        color: l_uint32,
        size: l_int32,
        addlabel: l_int32,
        location: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_chooseDisplayProg(selection: l_int32);
}
extern "C" {
    pub fn changeFormatForMissingLib(pformat: *mut l_int32);
}
extern "C" {
    pub fn pixDisplayWrite(pixs: *mut PIX, reduction: l_int32) -> l_ok;
}
extern "C" {
    pub fn zlibCompress(datain: *const l_uint8, nin: usize, pnout: *mut usize) -> *mut l_uint8;
}
extern "C" {
    pub fn zlibUncompress(datain: *const l_uint8, nin: usize, pnout: *mut usize) -> *mut l_uint8;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
pub type __uint128_t = u128;
#[doc = "< pixa of bitmaps for 93 characters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixa {
    pub _address: u8,
}
#[doc = "< clone of source pix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pix {
    pub _address: u8,
}
#[doc = "< tile locations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxa {
    pub _address: u8,
}
#[doc = "< sampled vert disparity array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPix {
    pub _address: u8,
}
#[doc = "< store (xpt, ypt) array"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pta {
    pub _address: u8,
}
#[doc = "< bounding region for all images"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Box {
    pub _address: u8,
}
#[doc = "< instances for each class; unbordered"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixaa {
    pub _address: u8,
}
